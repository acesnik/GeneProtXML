#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Wed Dec  9 17:21:19 2015 by generateDS.py version 2.17a.
#
# Command line options:
#   ('-o', '/Users/anthonycesnik/Downloads/uniprot.xsd.py')
#
# Command line arguments:
#   /Users/anthonycesnik/Downloads/uniprot.xsd.xml
#
# Command line:
#   /Users/anthonycesnik/Downloads/generateDS-2.17a0/generateDS.py -o "/Users/anthonycesnik/Downloads/uniprot.xsd.py" /Users/anthonycesnik/Downloads/uniprot.xsd.xml
#
# Current working directory (os.getcwd()):
#   generateDS-2.17a0
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
from lxml import etree as etree_


Validate_simpletypes_ = True


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        parser = etree_.ETCompatXMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class uniprot(GeneratedsSuper):
    """Describes a collection of UniProtKB entries."""
    subclass = None
    superclass = None
    def __init__(self, entry=None, copyright=None):
        self.original_tagname_ = None
        if entry is None:
            self.entry = []
        else:
            self.entry = entry
        self.copyright = copyright
    def factory(*args_, **kwargs_):
        if uniprot.subclass:
            return uniprot.subclass(*args_, **kwargs_)
        else:
            return uniprot(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_entry(self): return self.entry
    def set_entry(self, entry): self.entry = entry
    def add_entry(self, value): self.entry.append(value)
    def insert_entry_at(self, index, value): self.entry.insert(index, value)
    def replace_entry_at(self, index, value): self.entry[index] = value
    def get_copyright(self): return self.copyright
    def set_copyright(self, copyright): self.copyright = copyright
    def hasContent_(self):
        if (
            self.entry or
            self.copyright is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='uniprot', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='uniprot')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='uniprot', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='uniprot'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='uniprot', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for entry_ in self.entry:
            entry_.export(outfile, level, namespace_, name_='entry', pretty_print=pretty_print)
        if self.copyright is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scopyright>%s</%scopyright>%s' % (namespace_, self.gds_format_string(quote_xml(self.copyright).encode(ExternalEncoding), input_name='copyright'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'entry':
            obj_ = entry.factory()
            obj_.build(child_)
            self.entry.append(obj_)
            obj_.original_tagname_ = 'entry'
        elif nodeName_ == 'copyright':
            copyright_ = child_.text
            copyright_ = self.gds_validate_string(copyright_, node, 'copyright')
            self.copyright = copyright_
# end class uniprot


class entry(GeneratedsSuper):
    """Describes a UniProtKB entry."""
    subclass = None
    superclass = None
    def __init__(self, created=None, modified=None, version=None, dataset=None, accession=None, name=None, protein=None, gene=None, organism=None, organismHost=None, geneLocation=None, reference=None, comment=None, dbReference=None, proteinExistence=None, keyword=None, feature=None, evidence=None, sequence=None):
        self.original_tagname_ = None
        if isinstance(created, basestring):
            initvalue_ = datetime_.datetime.strptime(created, '%Y-%m-%d').date()
        else:
            initvalue_ = created
        self.created = initvalue_
        if isinstance(modified, basestring):
            initvalue_ = datetime_.datetime.strptime(modified, '%Y-%m-%d').date()
        else:
            initvalue_ = modified
        self.modified = initvalue_
        self.version = _cast(int, version)
        self.dataset = _cast(None, dataset)
        if accession is None:
            self.accession = []
        else:
            self.accession = accession
        if name is None:
            self.name = []
        else:
            self.name = name
        self.protein = protein
        if gene is None:
            self.gene = []
        else:
            self.gene = gene
        self.organism = organism
        if organismHost is None:
            self.organismHost = []
        else:
            self.organismHost = organismHost
        if geneLocation is None:
            self.geneLocation = []
        else:
            self.geneLocation = geneLocation
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        if comment is None:
            self.comment = []
        else:
            self.comment = comment
        if dbReference is None:
            self.dbReference = []
        else:
            self.dbReference = dbReference
        self.proteinExistence = proteinExistence
        if keyword is None:
            self.keyword = []
        else:
            self.keyword = keyword
        if feature is None:
            self.feature = []
        else:
            self.feature = feature
        if evidence is None:
            self.evidence = []
        else:
            self.evidence = evidence
        self.sequence = sequence
    def factory(*args_, **kwargs_):
        if entry.subclass:
            return entry.subclass(*args_, **kwargs_)
        else:
            return entry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_accession(self): return self.accession
    def set_accession(self, accession): self.accession = accession
    def add_accession(self, value): self.accession.append(value)
    def insert_accession_at(self, index, value): self.accession.insert(index, value)
    def replace_accession_at(self, index, value): self.accession[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def add_name(self, value): self.name.append(value)
    def insert_name_at(self, index, value): self.name.insert(index, value)
    def replace_name_at(self, index, value): self.name[index] = value
    def get_protein(self): return self.protein
    def set_protein(self, protein): self.protein = protein
    def get_gene(self): return self.gene
    def set_gene(self, gene): self.gene = gene
    def add_gene(self, value): self.gene.append(value)
    def insert_gene_at(self, index, value): self.gene.insert(index, value)
    def replace_gene_at(self, index, value): self.gene[index] = value
    def get_organism(self): return self.organism
    def set_organism(self, organism): self.organism = organism
    def get_organismHost(self): return self.organismHost
    def set_organismHost(self, organismHost): self.organismHost = organismHost
    def add_organismHost(self, value): self.organismHost.append(value)
    def insert_organismHost_at(self, index, value): self.organismHost.insert(index, value)
    def replace_organismHost_at(self, index, value): self.organismHost[index] = value
    def get_geneLocation(self): return self.geneLocation
    def set_geneLocation(self, geneLocation): self.geneLocation = geneLocation
    def add_geneLocation(self, value): self.geneLocation.append(value)
    def insert_geneLocation_at(self, index, value): self.geneLocation.insert(index, value)
    def replace_geneLocation_at(self, index, value): self.geneLocation[index] = value
    def get_reference(self): return self.reference
    def set_reference(self, reference): self.reference = reference
    def add_reference(self, value): self.reference.append(value)
    def insert_reference_at(self, index, value): self.reference.insert(index, value)
    def replace_reference_at(self, index, value): self.reference[index] = value
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def add_comment(self, value): self.comment.append(value)
    def insert_comment_at(self, index, value): self.comment.insert(index, value)
    def replace_comment_at(self, index, value): self.comment[index] = value
    def get_dbReference(self): return self.dbReference
    def set_dbReference(self, dbReference): self.dbReference = dbReference
    def add_dbReference(self, value): self.dbReference.append(value)
    def insert_dbReference_at(self, index, value): self.dbReference.insert(index, value)
    def replace_dbReference_at(self, index, value): self.dbReference[index] = value
    def get_proteinExistence(self): return self.proteinExistence
    def set_proteinExistence(self, proteinExistence): self.proteinExistence = proteinExistence
    def get_keyword(self): return self.keyword
    def set_keyword(self, keyword): self.keyword = keyword
    def add_keyword(self, value): self.keyword.append(value)
    def insert_keyword_at(self, index, value): self.keyword.insert(index, value)
    def replace_keyword_at(self, index, value): self.keyword[index] = value
    def get_feature(self): return self.feature
    def set_feature(self, feature): self.feature = feature
    def add_feature(self, value): self.feature.append(value)
    def insert_feature_at(self, index, value): self.feature.insert(index, value)
    def replace_feature_at(self, index, value): self.feature[index] = value
    def get_evidence(self): return self.evidence
    def set_evidence(self, evidence): self.evidence = evidence
    def add_evidence(self, value): self.evidence.append(value)
    def insert_evidence_at(self, index, value): self.evidence.insert(index, value)
    def replace_evidence_at(self, index, value): self.evidence[index] = value
    def get_sequence(self): return self.sequence
    def set_sequence(self, sequence): self.sequence = sequence
    def get_created(self): return self.created
    def set_created(self, created): self.created = created
    def get_modified(self): return self.modified
    def set_modified(self, modified): self.modified = modified
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_dataset(self): return self.dataset
    def set_dataset(self, dataset): self.dataset = dataset
    def hasContent_(self):
        if (
            self.accession or
            self.name or
            self.protein is not None or
            self.gene or
            self.organism is not None or
            self.organismHost or
            self.geneLocation or
            self.reference or
            self.comment or
            self.dbReference or
            self.proteinExistence is not None or
            self.keyword or
            self.feature or
            self.evidence or
            self.sequence is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='entry', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='entry')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='entry', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='entry'):
        if self.created is not None and 'created' not in already_processed:
            already_processed.add('created')
            outfile.write(' created="%s"' % self.gds_format_date(self.created, input_name='created'))
        if self.modified is not None and 'modified' not in already_processed:
            already_processed.add('modified')
            outfile.write(' modified="%s"' % self.gds_format_date(self.modified, input_name='modified'))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version="%s"' % self.gds_format_integer(self.version, input_name='version'))
        if self.dataset is not None and 'dataset' not in already_processed:
            already_processed.add('dataset')
            outfile.write(' dataset=%s' % (self.gds_format_string(quote_attrib(self.dataset).encode(ExternalEncoding), input_name='dataset'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='entry', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for accession_ in self.accession:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saccession>%s</%saccession>%s' % (namespace_, self.gds_format_string(quote_xml(accession_).encode(ExternalEncoding), input_name='accession'), namespace_, eol_))
        for name_ in self.name:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(name_).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.protein is not None:
            self.protein.export(outfile, level, namespace_, name_='protein', pretty_print=pretty_print)
        for gene_ in self.gene:
            gene_.export(outfile, level, namespace_, name_='gene', pretty_print=pretty_print)
        if self.organism is not None:
            self.organism.export(outfile, level, namespace_, name_='organism', pretty_print=pretty_print)
        for organismHost_ in self.organismHost:
            organismHost_.export(outfile, level, namespace_, name_='organismHost', pretty_print=pretty_print)
        for geneLocation_ in self.geneLocation:
            geneLocation_.export(outfile, level, namespace_, name_='geneLocation', pretty_print=pretty_print)
        for reference_ in self.reference:
            reference_.export(outfile, level, namespace_, name_='reference', pretty_print=pretty_print)
        for comment_ in self.comment:
            comment_.export(outfile, level, namespace_, name_='comment', pretty_print=pretty_print)
        for dbReference_ in self.dbReference:
            dbReference_.export(outfile, level, namespace_, name_='dbReference', pretty_print=pretty_print)
        if self.proteinExistence is not None:
            self.proteinExistence.export(outfile, level, namespace_, name_='proteinExistence', pretty_print=pretty_print)
        for keyword_ in self.keyword:
            keyword_.export(outfile, level, namespace_, name_='keyword', pretty_print=pretty_print)
        for feature_ in self.feature:
            feature_.export(outfile, level, namespace_, name_='feature', pretty_print=pretty_print)
        for evidence_ in self.evidence:
            evidence_.export(outfile, level, namespace_, name_='evidence', pretty_print=pretty_print)
        if self.sequence is not None:
            self.sequence.export(outfile, level, namespace_, name_='sequence', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('created', node)
        if value is not None and 'created' not in already_processed:
            already_processed.add('created')
            try:
                self.created = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (created): %s' % exp)
        value = find_attr_value_('modified', node)
        if value is not None and 'modified' not in already_processed:
            already_processed.add('modified')
            try:
                self.modified = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (modified): %s' % exp)
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            try:
                self.version = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('dataset', node)
        if value is not None and 'dataset' not in already_processed:
            already_processed.add('dataset')
            self.dataset = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'accession':
            accession_ = child_.text
            accession_ = self.gds_validate_string(accession_, node, 'accession')
            self.accession.append(accession_)
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name.append(name_)
        elif nodeName_ == 'protein':
            obj_ = proteinType.factory()
            obj_.build(child_)
            self.protein = obj_
            obj_.original_tagname_ = 'protein'
        elif nodeName_ == 'gene':
            obj_ = geneType.factory()
            obj_.build(child_)
            self.gene.append(obj_)
            obj_.original_tagname_ = 'gene'
        elif nodeName_ == 'organism':
            obj_ = organismType.factory()
            obj_.build(child_)
            self.organism = obj_
            obj_.original_tagname_ = 'organism'
        elif nodeName_ == 'organismHost':
            obj_ = organismType.factory()
            obj_.build(child_)
            self.organismHost.append(obj_)
            obj_.original_tagname_ = 'organismHost'
        elif nodeName_ == 'geneLocation':
            obj_ = geneLocationType.factory()
            obj_.build(child_)
            self.geneLocation.append(obj_)
            obj_.original_tagname_ = 'geneLocation'
        elif nodeName_ == 'reference':
            obj_ = referenceType.factory()
            obj_.build(child_)
            self.reference.append(obj_)
            obj_.original_tagname_ = 'reference'
        elif nodeName_ == 'comment':
            obj_ = commentType.factory()
            obj_.build(child_)
            self.comment.append(obj_)
            obj_.original_tagname_ = 'comment'
        elif nodeName_ == 'dbReference':
            obj_ = dbReferenceType.factory()
            obj_.build(child_)
            self.dbReference.append(obj_)
            obj_.original_tagname_ = 'dbReference'
        elif nodeName_ == 'proteinExistence':
            obj_ = proteinExistenceType.factory()
            obj_.build(child_)
            self.proteinExistence = obj_
            obj_.original_tagname_ = 'proteinExistence'
        elif nodeName_ == 'keyword':
            obj_ = keywordType.factory()
            obj_.build(child_)
            self.keyword.append(obj_)
            obj_.original_tagname_ = 'keyword'
        elif nodeName_ == 'feature':
            obj_ = featureType.factory()
            obj_.build(child_)
            self.feature.append(obj_)
            obj_.original_tagname_ = 'feature'
        elif nodeName_ == 'evidence':
            obj_ = evidenceType.factory()
            obj_.build(child_)
            self.evidence.append(obj_)
            obj_.original_tagname_ = 'evidence'
        elif nodeName_ == 'sequence':
            obj_ = sequenceType.factory()
            obj_.build(child_)
            self.sequence = obj_
            obj_.original_tagname_ = 'sequence'
# end class entry


class proteinType(GeneratedsSuper):
    """Describes the names for the protein and parts thereof. Equivalent to
    the flat file DE-line."""
    subclass = None
    superclass = None
    def __init__(self, recommendedName=None, alternativeName=None, submittedName=None, allergenName=None, biotechName=None, cdAntigenName=None, innName=None, domain=None, component=None):
        self.original_tagname_ = None
        self.recommendedName = recommendedName
        if alternativeName is None:
            self.alternativeName = []
        else:
            self.alternativeName = alternativeName
        if submittedName is None:
            self.submittedName = []
        else:
            self.submittedName = submittedName
        self.allergenName = allergenName
        self.biotechName = biotechName
        if cdAntigenName is None:
            self.cdAntigenName = []
        else:
            self.cdAntigenName = cdAntigenName
        if innName is None:
            self.innName = []
        else:
            self.innName = innName
        if domain is None:
            self.domain = []
        else:
            self.domain = domain
        if component is None:
            self.component = []
        else:
            self.component = component
    def factory(*args_, **kwargs_):
        if proteinType.subclass:
            return proteinType.subclass(*args_, **kwargs_)
        else:
            return proteinType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_recommendedName(self): return self.recommendedName
    def set_recommendedName(self, recommendedName): self.recommendedName = recommendedName
    def get_alternativeName(self): return self.alternativeName
    def set_alternativeName(self, alternativeName): self.alternativeName = alternativeName
    def add_alternativeName(self, value): self.alternativeName.append(value)
    def insert_alternativeName_at(self, index, value): self.alternativeName.insert(index, value)
    def replace_alternativeName_at(self, index, value): self.alternativeName[index] = value
    def get_submittedName(self): return self.submittedName
    def set_submittedName(self, submittedName): self.submittedName = submittedName
    def add_submittedName(self, value): self.submittedName.append(value)
    def insert_submittedName_at(self, index, value): self.submittedName.insert(index, value)
    def replace_submittedName_at(self, index, value): self.submittedName[index] = value
    def get_allergenName(self): return self.allergenName
    def set_allergenName(self, allergenName): self.allergenName = allergenName
    def get_biotechName(self): return self.biotechName
    def set_biotechName(self, biotechName): self.biotechName = biotechName
    def get_cdAntigenName(self): return self.cdAntigenName
    def set_cdAntigenName(self, cdAntigenName): self.cdAntigenName = cdAntigenName
    def add_cdAntigenName(self, value): self.cdAntigenName.append(value)
    def insert_cdAntigenName_at(self, index, value): self.cdAntigenName.insert(index, value)
    def replace_cdAntigenName_at(self, index, value): self.cdAntigenName[index] = value
    def get_innName(self): return self.innName
    def set_innName(self, innName): self.innName = innName
    def add_innName(self, value): self.innName.append(value)
    def insert_innName_at(self, index, value): self.innName.insert(index, value)
    def replace_innName_at(self, index, value): self.innName[index] = value
    def get_domain(self): return self.domain
    def set_domain(self, domain): self.domain = domain
    def add_domain(self, value): self.domain.append(value)
    def insert_domain_at(self, index, value): self.domain.insert(index, value)
    def replace_domain_at(self, index, value): self.domain[index] = value
    def get_component(self): return self.component
    def set_component(self, component): self.component = component
    def add_component(self, value): self.component.append(value)
    def insert_component_at(self, index, value): self.component.insert(index, value)
    def replace_component_at(self, index, value): self.component[index] = value
    def hasContent_(self):
        if (
            self.recommendedName is not None or
            self.alternativeName or
            self.submittedName or
            self.allergenName is not None or
            self.biotechName is not None or
            self.cdAntigenName or
            self.innName or
            self.domain or
            self.component
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='proteinType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='proteinType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='proteinType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='proteinType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='proteinType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.recommendedName is not None:
            self.recommendedName.export(outfile, level, namespace_, name_='recommendedName', pretty_print=pretty_print)
        for alternativeName_ in self.alternativeName:
            alternativeName_.export(outfile, level, namespace_, name_='alternativeName', pretty_print=pretty_print)
        for submittedName_ in self.submittedName:
            submittedName_.export(outfile, level, namespace_, name_='submittedName', pretty_print=pretty_print)
        if self.allergenName is not None:
            self.allergenName.export(outfile, level, namespace_, name_='allergenName', pretty_print=pretty_print)
        if self.biotechName is not None:
            self.biotechName.export(outfile, level, namespace_, name_='biotechName', pretty_print=pretty_print)
        for cdAntigenName_ in self.cdAntigenName:
            cdAntigenName_.export(outfile, level, namespace_, name_='cdAntigenName', pretty_print=pretty_print)
        for innName_ in self.innName:
            innName_.export(outfile, level, namespace_, name_='innName', pretty_print=pretty_print)
        for domain_ in self.domain:
            domain_.export(outfile, level, namespace_, name_='domain', pretty_print=pretty_print)
        for component_ in self.component:
            component_.export(outfile, level, namespace_, name_='component', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'recommendedName':
            obj_ = recommendedNameType.factory()
            obj_.build(child_)
            self.recommendedName = obj_
            obj_.original_tagname_ = 'recommendedName'
        elif nodeName_ == 'alternativeName':
            obj_ = alternativeNameType.factory()
            obj_.build(child_)
            self.alternativeName.append(obj_)
            obj_.original_tagname_ = 'alternativeName'
        elif nodeName_ == 'submittedName':
            obj_ = submittedNameType.factory()
            obj_.build(child_)
            self.submittedName.append(obj_)
            obj_.original_tagname_ = 'submittedName'
        elif nodeName_ == 'allergenName':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.allergenName = obj_
            obj_.original_tagname_ = 'allergenName'
        elif nodeName_ == 'biotechName':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.biotechName = obj_
            obj_.original_tagname_ = 'biotechName'
        elif nodeName_ == 'cdAntigenName':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.cdAntigenName.append(obj_)
            obj_.original_tagname_ = 'cdAntigenName'
        elif nodeName_ == 'innName':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.innName.append(obj_)
            obj_.original_tagname_ = 'innName'
        elif nodeName_ == 'domain':
            obj_ = domainType.factory()
            obj_.build(child_)
            self.domain.append(obj_)
            obj_.original_tagname_ = 'domain'
        elif nodeName_ == 'component':
            obj_ = componentType.factory()
            obj_.build(child_)
            self.component.append(obj_)
            obj_.original_tagname_ = 'component'
# end class proteinType


class geneType(GeneratedsSuper):
    """Describes a gene. Equivalent to the flat file GN-line."""
    subclass = None
    superclass = None
    def __init__(self, name=None):
        self.original_tagname_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
    def factory(*args_, **kwargs_):
        if geneType.subclass:
            return geneType.subclass(*args_, **kwargs_)
        else:
            return geneType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def add_name(self, value): self.name.append(value)
    def insert_name_at(self, index, value): self.name.insert(index, value)
    def replace_name_at(self, index, value): self.name[index] = value
    def hasContent_(self):
        if (
            self.name
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='geneType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='geneType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='geneType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='geneType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='geneType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for name_ in self.name:
            name_.export(outfile, level, namespace_, name_='name', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            obj_ = geneNameType.factory()
            obj_.build(child_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
# end class geneType


class geneNameType(GeneratedsSuper):
    """Describes different types of gene designations. Equivalent to the
    flat file GN-line."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, evidence=None, valueOf_=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.evidence = _cast(None, evidence)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if geneNameType.subclass:
            return geneNameType.subclass(*args_, **kwargs_)
        else:
            return geneNameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_evidence(self): return self.evidence
    def set_evidence(self, evidence): self.evidence = evidence
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_intListType(self, value):
        # Validate type intListType, a restriction on xs:int.
        pass
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='geneNameType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='geneNameType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='geneNameType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='geneNameType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.evidence is not None and 'evidence' not in already_processed:
            already_processed.add('evidence')
            outfile.write(' evidence=%s' % (quote_attrib(self.evidence), ))
    def exportChildren(self, outfile, level, namespace_='', name_='geneNameType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('evidence', node)
        if value is not None and 'evidence' not in already_processed:
            already_processed.add('evidence')
            try:
                self.evidence = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_intListType(self.evidence)    # validate type intListType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class geneNameType


class organismType(GeneratedsSuper):
    """Describes the source organism."""
    subclass = None
    superclass = None
    def __init__(self, evidence=None, name=None, dbReference=None, lineage=None):
        self.original_tagname_ = None
        self.evidence = _cast(None, evidence)
        if name is None:
            self.name = []
        else:
            self.name = name
        if dbReference is None:
            self.dbReference = []
        else:
            self.dbReference = dbReference
        self.lineage = lineage
    def factory(*args_, **kwargs_):
        if organismType.subclass:
            return organismType.subclass(*args_, **kwargs_)
        else:
            return organismType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def add_name(self, value): self.name.append(value)
    def insert_name_at(self, index, value): self.name.insert(index, value)
    def replace_name_at(self, index, value): self.name[index] = value
    def get_dbReference(self): return self.dbReference
    def set_dbReference(self, dbReference): self.dbReference = dbReference
    def add_dbReference(self, value): self.dbReference.append(value)
    def insert_dbReference_at(self, index, value): self.dbReference.insert(index, value)
    def replace_dbReference_at(self, index, value): self.dbReference[index] = value
    def get_lineage(self): return self.lineage
    def set_lineage(self, lineage): self.lineage = lineage
    def get_evidence(self): return self.evidence
    def set_evidence(self, evidence): self.evidence = evidence
    def validate_intListType(self, value):
        # Validate type intListType, a restriction on xs:int.
        pass
    def hasContent_(self):
        if (
            self.name or
            self.dbReference or
            self.lineage is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='organismType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='organismType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='organismType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='organismType'):
        if self.evidence is not None and 'evidence' not in already_processed:
            already_processed.add('evidence')
            outfile.write(' evidence=%s' % (quote_attrib(self.evidence), ))
    def exportChildren(self, outfile, level, namespace_='', name_='organismType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for name_ in self.name:
            name_.export(outfile, level, namespace_, name_='name', pretty_print=pretty_print)
        for dbReference_ in self.dbReference:
            dbReference_.export(outfile, level, namespace_, name_='dbReference', pretty_print=pretty_print)
        if self.lineage is not None:
            self.lineage.export(outfile, level, namespace_, name_='lineage', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('evidence', node)
        if value is not None and 'evidence' not in already_processed:
            already_processed.add('evidence')
            try:
                self.evidence = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_intListType(self.evidence)    # validate type intListType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            obj_ = organismNameType.factory()
            obj_.build(child_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'dbReference':
            obj_ = dbReferenceType.factory()
            obj_.build(child_)
            self.dbReference.append(obj_)
            obj_.original_tagname_ = 'dbReference'
        elif nodeName_ == 'lineage':
            obj_ = lineageType.factory()
            obj_.build(child_)
            self.lineage = obj_
            obj_.original_tagname_ = 'lineage'
# end class organismType


class organismNameType(GeneratedsSuper):
    """Describes different types of source organism names."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, valueOf_=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if organismNameType.subclass:
            return organismNameType.subclass(*args_, **kwargs_)
        else:
            return organismNameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='organismNameType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='organismNameType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='organismNameType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='organismNameType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='organismNameType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class organismNameType


class geneLocationType(GeneratedsSuper):
    """Describes non-nuclear gene locations (organelles and plasmids).
    Equivalent to the flat file OG-line."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, evidence=None, name=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.evidence = _cast(None, evidence)
        if name is None:
            self.name = []
        else:
            self.name = name
    def factory(*args_, **kwargs_):
        if geneLocationType.subclass:
            return geneLocationType.subclass(*args_, **kwargs_)
        else:
            return geneLocationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def add_name(self, value): self.name.append(value)
    def insert_name_at(self, index, value): self.name.insert(index, value)
    def replace_name_at(self, index, value): self.name[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_evidence(self): return self.evidence
    def set_evidence(self, evidence): self.evidence = evidence
    def validate_intListType(self, value):
        # Validate type intListType, a restriction on xs:int.
        pass
    def hasContent_(self):
        if (
            self.name
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='geneLocationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='geneLocationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='geneLocationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='geneLocationType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.evidence is not None and 'evidence' not in already_processed:
            already_processed.add('evidence')
            outfile.write(' evidence=%s' % (quote_attrib(self.evidence), ))
    def exportChildren(self, outfile, level, namespace_='', name_='geneLocationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for name_ in self.name:
            name_.export(outfile, level, namespace_, name_='name', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('evidence', node)
        if value is not None and 'evidence' not in already_processed:
            already_processed.add('evidence')
            try:
                self.evidence = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_intListType(self.evidence)    # validate type intListType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            obj_ = statusType.factory()
            obj_.build(child_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
# end class geneLocationType


class statusType(GeneratedsSuper):
    """Indicates whether the name of a plasmid is known or unknown."""
    subclass = None
    superclass = None
    def __init__(self, status='known', valueOf_=None):
        self.original_tagname_ = None
        self.status = _cast(None, status)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if statusType.subclass:
            return statusType.subclass(*args_, **kwargs_)
        else:
            return statusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='statusType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='statusType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='statusType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='statusType'):
        if self.status != "known" and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (self.gds_format_string(quote_attrib(self.status).encode(ExternalEncoding), input_name='status'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='statusType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class statusType


class referenceType(GeneratedsSuper):
    """Describes a citation and a summary of its content. Equivalent to the
    flat file RN-, RP-, RC-, RX-, RG-, RA-, RT- and RL-lines."""
    subclass = None
    superclass = None
    def __init__(self, key=None, evidence=None, citation=None, scope=None, source=None):
        self.original_tagname_ = None
        self.key = _cast(None, key)
        self.evidence = _cast(None, evidence)
        self.citation = citation
        if scope is None:
            self.scope = []
        else:
            self.scope = scope
        self.source = source
    def factory(*args_, **kwargs_):
        if referenceType.subclass:
            return referenceType.subclass(*args_, **kwargs_)
        else:
            return referenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_citation(self): return self.citation
    def set_citation(self, citation): self.citation = citation
    def get_scope(self): return self.scope
    def set_scope(self, scope): self.scope = scope
    def add_scope(self, value): self.scope.append(value)
    def insert_scope_at(self, index, value): self.scope.insert(index, value)
    def replace_scope_at(self, index, value): self.scope[index] = value
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def get_evidence(self): return self.evidence
    def set_evidence(self, evidence): self.evidence = evidence
    def validate_intListType(self, value):
        # Validate type intListType, a restriction on xs:int.
        pass
    def hasContent_(self):
        if (
            self.citation is not None or
            self.scope or
            self.source is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='referenceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='referenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='referenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='referenceType'):
        if self.key is not None and 'key' not in already_processed:
            already_processed.add('key')
            outfile.write(' key=%s' % (self.gds_format_string(quote_attrib(self.key).encode(ExternalEncoding), input_name='key'), ))
        if self.evidence is not None and 'evidence' not in already_processed:
            already_processed.add('evidence')
            outfile.write(' evidence=%s' % (quote_attrib(self.evidence), ))
    def exportChildren(self, outfile, level, namespace_='', name_='referenceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.citation is not None:
            self.citation.export(outfile, level, namespace_, name_='citation', pretty_print=pretty_print)
        for scope_ in self.scope:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sscope>%s</%sscope>%s' % (namespace_, self.gds_format_string(quote_xml(scope_).encode(ExternalEncoding), input_name='scope'), namespace_, eol_))
        if self.source is not None:
            self.source.export(outfile, level, namespace_, name_='source', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('key', node)
        if value is not None and 'key' not in already_processed:
            already_processed.add('key')
            self.key = value
        value = find_attr_value_('evidence', node)
        if value is not None and 'evidence' not in already_processed:
            already_processed.add('evidence')
            try:
                self.evidence = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_intListType(self.evidence)    # validate type intListType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'citation':
            obj_ = citationType.factory()
            obj_.build(child_)
            self.citation = obj_
            obj_.original_tagname_ = 'citation'
        elif nodeName_ == 'scope':
            scope_ = child_.text
            scope_ = self.gds_validate_string(scope_, node, 'scope')
            self.scope.append(scope_)
        elif nodeName_ == 'source':
            obj_ = sourceDataType.factory()
            obj_.build(child_)
            self.source = obj_
            obj_.original_tagname_ = 'source'
# end class referenceType


class citationType(GeneratedsSuper):
    """Describes different types of citations. Equivalent to the flat file
    RX-, RG-, RA-, RT- and RL-lines.Describes the type of a
    citation.Describes the name of an (online) journal or
    book.Describes the volume of a journal or book.Describes the
    first page of an article.Describes the last page of an
    article.Describes the publisher of a book.Describes the city
    where a book was published.Describes the database name of
    submissions.Describes a patent number.Describes the institute
    where a thesis was made.Describes the country where a thesis was
    made."""
    subclass = None
    superclass = None
    def __init__(self, publisher=None, last=None, name=None, city=None, institute=None, country=None, db=None, number=None, volume=None, date=None, type_=None, first=None, title=None, editorList=None, authorList=None, locator=None, dbReference=None):
        self.original_tagname_ = None
        self.publisher = _cast(None, publisher)
        self.last = _cast(None, last)
        self.name = _cast(None, name)
        self.city = _cast(None, city)
        self.institute = _cast(None, institute)
        self.country = _cast(None, country)
        self.db = _cast(None, db)
        self.number = _cast(None, number)
        self.volume = _cast(None, volume)
        self.date = _cast(None, date)
        self.type_ = _cast(None, type_)
        self.first = _cast(None, first)
        self.title = title
        self.editorList = editorList
        self.authorList = authorList
        self.locator = locator
        if dbReference is None:
            self.dbReference = []
        else:
            self.dbReference = dbReference
    def factory(*args_, **kwargs_):
        if citationType.subclass:
            return citationType.subclass(*args_, **kwargs_)
        else:
            return citationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_editorList(self): return self.editorList
    def set_editorList(self, editorList): self.editorList = editorList
    def get_authorList(self): return self.authorList
    def set_authorList(self, authorList): self.authorList = authorList
    def get_locator(self): return self.locator
    def set_locator(self, locator): self.locator = locator
    def get_dbReference(self): return self.dbReference
    def set_dbReference(self, dbReference): self.dbReference = dbReference
    def add_dbReference(self, value): self.dbReference.append(value)
    def insert_dbReference_at(self, index, value): self.dbReference.insert(index, value)
    def replace_dbReference_at(self, index, value): self.dbReference[index] = value
    def get_publisher(self): return self.publisher
    def set_publisher(self, publisher): self.publisher = publisher
    def get_last(self): return self.last
    def set_last(self, last): self.last = last
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_city(self): return self.city
    def set_city(self, city): self.city = city
    def get_institute(self): return self.institute
    def set_institute(self, institute): self.institute = institute
    def get_country(self): return self.country
    def set_country(self, country): self.country = country
    def get_db(self): return self.db
    def set_db(self, db): self.db = db
    def get_number(self): return self.number
    def set_number(self, number): self.number = number
    def get_volume(self): return self.volume
    def set_volume(self, volume): self.volume = volume
    def get_date(self): return self.date
    def set_date(self, date): self.date = date
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_first(self): return self.first
    def set_first(self, first): self.first = first
    def hasContent_(self):
        if (
            self.title is not None or
            self.editorList is not None or
            self.authorList is not None or
            self.locator is not None or
            self.dbReference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='citationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='citationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='citationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='citationType'):
        if self.publisher is not None and 'publisher' not in already_processed:
            already_processed.add('publisher')
            outfile.write(' publisher=%s' % (self.gds_format_string(quote_attrib(self.publisher).encode(ExternalEncoding), input_name='publisher'), ))
        if self.last is not None and 'last' not in already_processed:
            already_processed.add('last')
            outfile.write(' last=%s' % (self.gds_format_string(quote_attrib(self.last).encode(ExternalEncoding), input_name='last'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.city is not None and 'city' not in already_processed:
            already_processed.add('city')
            outfile.write(' city=%s' % (self.gds_format_string(quote_attrib(self.city).encode(ExternalEncoding), input_name='city'), ))
        if self.institute is not None and 'institute' not in already_processed:
            already_processed.add('institute')
            outfile.write(' institute=%s' % (self.gds_format_string(quote_attrib(self.institute).encode(ExternalEncoding), input_name='institute'), ))
        if self.country is not None and 'country' not in already_processed:
            already_processed.add('country')
            outfile.write(' country=%s' % (self.gds_format_string(quote_attrib(self.country).encode(ExternalEncoding), input_name='country'), ))
        if self.db is not None and 'db' not in already_processed:
            already_processed.add('db')
            outfile.write(' db=%s' % (self.gds_format_string(quote_attrib(self.db).encode(ExternalEncoding), input_name='db'), ))
        if self.number is not None and 'number' not in already_processed:
            already_processed.add('number')
            outfile.write(' number=%s' % (self.gds_format_string(quote_attrib(self.number).encode(ExternalEncoding), input_name='number'), ))
        if self.volume is not None and 'volume' not in already_processed:
            already_processed.add('volume')
            outfile.write(' volume=%s' % (self.gds_format_string(quote_attrib(self.volume).encode(ExternalEncoding), input_name='volume'), ))
        if self.date is not None and 'date' not in already_processed:
            already_processed.add('date')
            outfile.write(' date=%s' % (self.gds_format_string(quote_attrib(self.date).encode(ExternalEncoding), input_name='date'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.first is not None and 'first' not in already_processed:
            already_processed.add('first')
            outfile.write(' first=%s' % (self.gds_format_string(quote_attrib(self.first).encode(ExternalEncoding), input_name='first'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='citationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stitle>%s</%stitle>%s' % (namespace_, self.gds_format_string(quote_xml(self.title).encode(ExternalEncoding), input_name='title'), namespace_, eol_))
        if self.editorList is not None:
            self.editorList.export(outfile, level, namespace_, name_='editorList', pretty_print=pretty_print)
        if self.authorList is not None:
            self.authorList.export(outfile, level, namespace_, name_='authorList', pretty_print=pretty_print)
        if self.locator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slocator>%s</%slocator>%s' % (namespace_, self.gds_format_string(quote_xml(self.locator).encode(ExternalEncoding), input_name='locator'), namespace_, eol_))
        for dbReference_ in self.dbReference:
            dbReference_.export(outfile, level, namespace_, name_='dbReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('publisher', node)
        if value is not None and 'publisher' not in already_processed:
            already_processed.add('publisher')
            self.publisher = value
        value = find_attr_value_('last', node)
        if value is not None and 'last' not in already_processed:
            already_processed.add('last')
            self.last = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('city', node)
        if value is not None and 'city' not in already_processed:
            already_processed.add('city')
            self.city = value
        value = find_attr_value_('institute', node)
        if value is not None and 'institute' not in already_processed:
            already_processed.add('institute')
            self.institute = value
        value = find_attr_value_('country', node)
        if value is not None and 'country' not in already_processed:
            already_processed.add('country')
            self.country = value
        value = find_attr_value_('db', node)
        if value is not None and 'db' not in already_processed:
            already_processed.add('db')
            self.db = value
        value = find_attr_value_('number', node)
        if value is not None and 'number' not in already_processed:
            already_processed.add('number')
            self.number = value
        value = find_attr_value_('volume', node)
        if value is not None and 'volume' not in already_processed:
            already_processed.add('volume')
            self.volume = value
        value = find_attr_value_('date', node)
        if value is not None and 'date' not in already_processed:
            already_processed.add('date')
            self.date = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('first', node)
        if value is not None and 'first' not in already_processed:
            already_processed.add('first')
            self.first = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            title_ = child_.text
            title_ = self.gds_validate_string(title_, node, 'title')
            self.title = title_
        elif nodeName_ == 'editorList':
            obj_ = nameListType.factory()
            obj_.build(child_)
            self.editorList = obj_
            obj_.original_tagname_ = 'editorList'
        elif nodeName_ == 'authorList':
            obj_ = nameListType.factory()
            obj_.build(child_)
            self.authorList = obj_
            obj_.original_tagname_ = 'authorList'
        elif nodeName_ == 'locator':
            locator_ = child_.text
            locator_ = self.gds_validate_string(locator_, node, 'locator')
            self.locator = locator_
        elif nodeName_ == 'dbReference':
            obj_ = dbReferenceType.factory()
            obj_.build(child_)
            self.dbReference.append(obj_)
            obj_.original_tagname_ = 'dbReference'
# end class citationType


class consortiumType(GeneratedsSuper):
    """Describes the authors of a citation when these are represented by a
    consortium. Equivalent to the flat file RG-line."""
    subclass = None
    superclass = None
    def __init__(self, name=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
    def factory(*args_, **kwargs_):
        if consortiumType.subclass:
            return consortiumType.subclass(*args_, **kwargs_)
        else:
            return consortiumType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='consortiumType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='consortiumType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='consortiumType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='consortiumType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='consortiumType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class consortiumType


class personType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
    def factory(*args_, **kwargs_):
        if personType.subclass:
            return personType.subclass(*args_, **kwargs_)
        else:
            return personType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='personType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='personType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='personType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='personType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='personType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class personType


class nameListType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, consortium=None, person=None):
        self.original_tagname_ = None
        if consortium is None:
            self.consortium = []
        else:
            self.consortium = consortium
        if person is None:
            self.person = []
        else:
            self.person = person
    def factory(*args_, **kwargs_):
        if nameListType.subclass:
            return nameListType.subclass(*args_, **kwargs_)
        else:
            return nameListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_consortium(self): return self.consortium
    def set_consortium(self, consortium): self.consortium = consortium
    def add_consortium(self, value): self.consortium.append(value)
    def insert_consortium_at(self, index, value): self.consortium.insert(index, value)
    def replace_consortium_at(self, index, value): self.consortium[index] = value
    def get_person(self): return self.person
    def set_person(self, person): self.person = person
    def add_person(self, value): self.person.append(value)
    def insert_person_at(self, index, value): self.person.insert(index, value)
    def replace_person_at(self, index, value): self.person[index] = value
    def hasContent_(self):
        if (
            self.consortium or
            self.person
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='nameListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nameListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='nameListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='nameListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='nameListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for consortium_ in self.consortium:
            consortium_.export(outfile, level, namespace_, name_='consortium', pretty_print=pretty_print)
        for person_ in self.person:
            person_.export(outfile, level, namespace_, name_='person', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'consortium':
            obj_ = consortiumType.factory()
            obj_.build(child_)
            self.consortium.append(obj_)
            obj_.original_tagname_ = 'consortium'
        elif nodeName_ == 'person':
            obj_ = personType.factory()
            obj_.build(child_)
            self.person.append(obj_)
            obj_.original_tagname_ = 'person'
# end class nameListType


class sourceDataType(GeneratedsSuper):
    """Describes the source of the sequence according to the citation.
    Equivalent to the flat file RC-line."""
    subclass = None
    superclass = None
    def __init__(self, strain=None, plasmid=None, transposon=None, tissue=None):
        self.original_tagname_ = None
        if strain is None:
            self.strain = []
        else:
            self.strain = strain
        if plasmid is None:
            self.plasmid = []
        else:
            self.plasmid = plasmid
        if transposon is None:
            self.transposon = []
        else:
            self.transposon = transposon
        if tissue is None:
            self.tissue = []
        else:
            self.tissue = tissue
    def factory(*args_, **kwargs_):
        if sourceDataType.subclass:
            return sourceDataType.subclass(*args_, **kwargs_)
        else:
            return sourceDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_strain(self): return self.strain
    def set_strain(self, strain): self.strain = strain
    def add_strain(self, value): self.strain.append(value)
    def insert_strain_at(self, index, value): self.strain.insert(index, value)
    def replace_strain_at(self, index, value): self.strain[index] = value
    def get_plasmid(self): return self.plasmid
    def set_plasmid(self, plasmid): self.plasmid = plasmid
    def add_plasmid(self, value): self.plasmid.append(value)
    def insert_plasmid_at(self, index, value): self.plasmid.insert(index, value)
    def replace_plasmid_at(self, index, value): self.plasmid[index] = value
    def get_transposon(self): return self.transposon
    def set_transposon(self, transposon): self.transposon = transposon
    def add_transposon(self, value): self.transposon.append(value)
    def insert_transposon_at(self, index, value): self.transposon.insert(index, value)
    def replace_transposon_at(self, index, value): self.transposon[index] = value
    def get_tissue(self): return self.tissue
    def set_tissue(self, tissue): self.tissue = tissue
    def add_tissue(self, value): self.tissue.append(value)
    def insert_tissue_at(self, index, value): self.tissue.insert(index, value)
    def replace_tissue_at(self, index, value): self.tissue[index] = value
    def hasContent_(self):
        if (
            self.strain or
            self.plasmid or
            self.transposon or
            self.tissue
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='sourceDataType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sourceDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='sourceDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='sourceDataType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='sourceDataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for strain_ in self.strain:
            strain_.export(outfile, level, namespace_, name_='strain', pretty_print=pretty_print)
        for plasmid_ in self.plasmid:
            plasmid_.export(outfile, level, namespace_, name_='plasmid', pretty_print=pretty_print)
        for transposon_ in self.transposon:
            transposon_.export(outfile, level, namespace_, name_='transposon', pretty_print=pretty_print)
        for tissue_ in self.tissue:
            tissue_.export(outfile, level, namespace_, name_='tissue', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'strain':
            obj_ = strainType.factory()
            obj_.build(child_)
            self.strain.append(obj_)
            obj_.original_tagname_ = 'strain'
        elif nodeName_ == 'plasmid':
            obj_ = plasmidType.factory()
            obj_.build(child_)
            self.plasmid.append(obj_)
            obj_.original_tagname_ = 'plasmid'
        elif nodeName_ == 'transposon':
            obj_ = transposonType.factory()
            obj_.build(child_)
            self.transposon.append(obj_)
            obj_.original_tagname_ = 'transposon'
        elif nodeName_ == 'tissue':
            obj_ = tissueType.factory()
            obj_.build(child_)
            self.tissue.append(obj_)
            obj_.original_tagname_ = 'tissue'
# end class sourceDataType


class commentType(GeneratedsSuper):
    """Describes different types of general annotations. Equivalent to the
    flat file CC-line.Used in 'cofactor' annotations.Used in
    'subcellular location' annotations.Used in 'alternative
    products' annotations.Used in 'interaction'
    annotations.Describes the type of a general annotation.
    Equivalent to the flat file CC comment topics (except for
    "DATABASE" which is translated to "online
    information").Describes the type of sequence location in 'RNA
    editing' annotations. Common values are "Not_applicable" and
    "Undetermined".Describes an optional name for an 'online
    information'.Describes the molecular mass in 'mass spectrometry'
    annotations.Describes the error of the mass measurement in 'mass
    spectrometry' annotations.Describes the experimental method in
    'mass spectrometry' annotations."""
    subclass = None
    superclass = None
    def __init__(self, name=None, locationType=None, evidence=None, mass=None, error=None, type_=None, method=None, molecule=None, absorption=None, kinetics=None, phDependence=None, redoxPotential=None, temperatureDependence=None, cofactor=None, subcellularLocation=None, conflict=None, link=None, event=None, isoform=None, interactant=None, organismsDiffer=False, experiments=None, disease=None, location=None, text=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.locationType = _cast(None, locationType)
        self.evidence = _cast(None, evidence)
        self.mass = _cast(float, mass)
        self.error = _cast(None, error)
        self.type_ = _cast(None, type_)
        self.method = _cast(None, method)
        self.molecule = molecule
        self.absorption = absorption
        self.kinetics = kinetics
        self.phDependence = phDependence
        self.redoxPotential = redoxPotential
        self.temperatureDependence = temperatureDependence
        if cofactor is None:
            self.cofactor = []
        else:
            self.cofactor = cofactor
        if subcellularLocation is None:
            self.subcellularLocation = []
        else:
            self.subcellularLocation = subcellularLocation
        self.conflict = conflict
        if link is None:
            self.link = []
        else:
            self.link = link
        if event is None:
            self.event = []
        else:
            self.event = event
        if isoform is None:
            self.isoform = []
        else:
            self.isoform = isoform
        if interactant is None:
            self.interactant = []
        else:
            self.interactant = interactant
        self.organismsDiffer = organismsDiffer
        self.experiments = experiments
        self.disease = disease
        if location is None:
            self.location = []
        else:
            self.location = location
        if text is None:
            self.text = []
        else:
            self.text = text
    def factory(*args_, **kwargs_):
        if commentType.subclass:
            return commentType.subclass(*args_, **kwargs_)
        else:
            return commentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_molecule(self): return self.molecule
    def set_molecule(self, molecule): self.molecule = molecule
    def get_absorption(self): return self.absorption
    def set_absorption(self, absorption): self.absorption = absorption
    def get_kinetics(self): return self.kinetics
    def set_kinetics(self, kinetics): self.kinetics = kinetics
    def get_phDependence(self): return self.phDependence
    def set_phDependence(self, phDependence): self.phDependence = phDependence
    def get_redoxPotential(self): return self.redoxPotential
    def set_redoxPotential(self, redoxPotential): self.redoxPotential = redoxPotential
    def get_temperatureDependence(self): return self.temperatureDependence
    def set_temperatureDependence(self, temperatureDependence): self.temperatureDependence = temperatureDependence
    def get_cofactor(self): return self.cofactor
    def set_cofactor(self, cofactor): self.cofactor = cofactor
    def add_cofactor(self, value): self.cofactor.append(value)
    def insert_cofactor_at(self, index, value): self.cofactor.insert(index, value)
    def replace_cofactor_at(self, index, value): self.cofactor[index] = value
    def get_subcellularLocation(self): return self.subcellularLocation
    def set_subcellularLocation(self, subcellularLocation): self.subcellularLocation = subcellularLocation
    def add_subcellularLocation(self, value): self.subcellularLocation.append(value)
    def insert_subcellularLocation_at(self, index, value): self.subcellularLocation.insert(index, value)
    def replace_subcellularLocation_at(self, index, value): self.subcellularLocation[index] = value
    def get_conflict(self): return self.conflict
    def set_conflict(self, conflict): self.conflict = conflict
    def get_link(self): return self.link
    def set_link(self, link): self.link = link
    def add_link(self, value): self.link.append(value)
    def insert_link_at(self, index, value): self.link.insert(index, value)
    def replace_link_at(self, index, value): self.link[index] = value
    def get_event(self): return self.event
    def set_event(self, event): self.event = event
    def add_event(self, value): self.event.append(value)
    def insert_event_at(self, index, value): self.event.insert(index, value)
    def replace_event_at(self, index, value): self.event[index] = value
    def get_isoform(self): return self.isoform
    def set_isoform(self, isoform): self.isoform = isoform
    def add_isoform(self, value): self.isoform.append(value)
    def insert_isoform_at(self, index, value): self.isoform.insert(index, value)
    def replace_isoform_at(self, index, value): self.isoform[index] = value
    def get_interactant(self): return self.interactant
    def set_interactant(self, interactant): self.interactant = interactant
    def add_interactant(self, value): self.interactant.append(value)
    def insert_interactant_at(self, index, value): self.interactant.insert(index, value)
    def replace_interactant_at(self, index, value): self.interactant[index] = value
    def get_organismsDiffer(self): return self.organismsDiffer
    def set_organismsDiffer(self, organismsDiffer): self.organismsDiffer = organismsDiffer
    def get_experiments(self): return self.experiments
    def set_experiments(self, experiments): self.experiments = experiments
    def get_disease(self): return self.disease
    def set_disease(self, disease): self.disease = disease
    def get_location(self): return self.location
    def set_location(self, location): self.location = location
    def add_location(self, value): self.location.append(value)
    def insert_location_at(self, index, value): self.location.insert(index, value)
    def replace_location_at(self, index, value): self.location[index] = value
    def get_text(self): return self.text
    def set_text(self, text): self.text = text
    def add_text(self, value): self.text.append(value)
    def insert_text_at(self, index, value): self.text.insert(index, value)
    def replace_text_at(self, index, value): self.text[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_locationType(self): return self.locationType
    def set_locationType(self, locationType): self.locationType = locationType
    def get_evidence(self): return self.evidence
    def set_evidence(self, evidence): self.evidence = evidence
    def get_mass(self): return self.mass
    def set_mass(self, mass): self.mass = mass
    def get_error(self): return self.error
    def set_error(self, error): self.error = error
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_method(self): return self.method
    def set_method(self, method): self.method = method
    def validate_intListType(self, value):
        # Validate type intListType, a restriction on xs:int.
        pass
    def hasContent_(self):
        if (
            self.molecule is not None or
            self.absorption is not None or
            self.kinetics is not None or
            self.phDependence is not None or
            self.redoxPotential is not None or
            self.temperatureDependence is not None or
            self.cofactor or
            self.subcellularLocation or
            self.conflict is not None or
            self.link or
            self.event or
            self.isoform or
            self.interactant or
            self.organismsDiffer or
            self.experiments is not None or
            self.disease is not None or
            self.location or
            self.text
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='commentType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='commentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='commentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='commentType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.locationType is not None and 'locationType' not in already_processed:
            already_processed.add('locationType')
            outfile.write(' locationType=%s' % (self.gds_format_string(quote_attrib(self.locationType).encode(ExternalEncoding), input_name='locationType'), ))
        if self.evidence is not None and 'evidence' not in already_processed:
            already_processed.add('evidence')
            outfile.write(' evidence=%s' % (quote_attrib(self.evidence), ))
        if self.mass is not None and 'mass' not in already_processed:
            already_processed.add('mass')
            outfile.write(' mass="%s"' % self.gds_format_float(self.mass, input_name='mass'))
        if self.error is not None and 'error' not in already_processed:
            already_processed.add('error')
            outfile.write(' error=%s' % (self.gds_format_string(quote_attrib(self.error).encode(ExternalEncoding), input_name='error'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.method is not None and 'method' not in already_processed:
            already_processed.add('method')
            outfile.write(' method=%s' % (self.gds_format_string(quote_attrib(self.method).encode(ExternalEncoding), input_name='method'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='commentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.molecule is not None:
            self.molecule.export(outfile, level, namespace_, name_='molecule', pretty_print=pretty_print)
        if self.absorption is not None:
            self.absorption.export(outfile, level, namespace_, name_='absorption', pretty_print=pretty_print)
        if self.kinetics is not None:
            self.kinetics.export(outfile, level, namespace_, name_='kinetics', pretty_print=pretty_print)
        if self.phDependence is not None:
            self.phDependence.export(outfile, level, namespace_, name_='phDependence', pretty_print=pretty_print)
        if self.redoxPotential is not None:
            self.redoxPotential.export(outfile, level, namespace_, name_='redoxPotential', pretty_print=pretty_print)
        if self.temperatureDependence is not None:
            self.temperatureDependence.export(outfile, level, namespace_, name_='temperatureDependence', pretty_print=pretty_print)
        for cofactor_ in self.cofactor:
            cofactor_.export(outfile, level, namespace_, name_='cofactor', pretty_print=pretty_print)
        for subcellularLocation_ in self.subcellularLocation:
            subcellularLocation_.export(outfile, level, namespace_, name_='subcellularLocation', pretty_print=pretty_print)
        if self.conflict is not None:
            self.conflict.export(outfile, level, namespace_, name_='conflict', pretty_print=pretty_print)
        for link_ in self.link:
            link_.export(outfile, level, namespace_, name_='link', pretty_print=pretty_print)
        for event_ in self.event:
            event_.export(outfile, level, namespace_, name_='event', pretty_print=pretty_print)
        for isoform_ in self.isoform:
            isoform_.export(outfile, level, namespace_, name_='isoform', pretty_print=pretty_print)
        for interactant_ in self.interactant:
            interactant_.export(outfile, level, namespace_, name_='interactant', pretty_print=pretty_print)
        if self.organismsDiffer:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorganismsDiffer>%s</%sorganismsDiffer>%s' % (namespace_, self.gds_format_boolean(self.organismsDiffer, input_name='organismsDiffer'), namespace_, eol_))
        if self.experiments is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexperiments>%s</%sexperiments>%s' % (namespace_, self.gds_format_integer(self.experiments, input_name='experiments'), namespace_, eol_))
        if self.disease is not None:
            self.disease.export(outfile, level, namespace_, name_='disease', pretty_print=pretty_print)
        for location_ in self.location:
            location_.export(outfile, level, namespace_, name_='location', pretty_print=pretty_print)
        for text_ in self.text:
            text_.export(outfile, level, namespace_, name_='text', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('locationType', node)
        if value is not None and 'locationType' not in already_processed:
            already_processed.add('locationType')
            self.locationType = value
        value = find_attr_value_('evidence', node)
        if value is not None and 'evidence' not in already_processed:
            already_processed.add('evidence')
            try:
                self.evidence = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_intListType(self.evidence)    # validate type intListType
        value = find_attr_value_('mass', node)
        if value is not None and 'mass' not in already_processed:
            already_processed.add('mass')
            try:
                self.mass = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (mass): %s' % exp)
        value = find_attr_value_('error', node)
        if value is not None and 'error' not in already_processed:
            already_processed.add('error')
            self.error = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('method', node)
        if value is not None and 'method' not in already_processed:
            already_processed.add('method')
            self.method = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'molecule':
            obj_ = moleculeType.factory()
            obj_.build(child_)
            self.molecule = obj_
            obj_.original_tagname_ = 'molecule'
        elif nodeName_ == 'absorption':
            obj_ = absorptionType.factory()
            obj_.build(child_)
            self.absorption = obj_
            obj_.original_tagname_ = 'absorption'
        elif nodeName_ == 'kinetics':
            obj_ = kineticsType.factory()
            obj_.build(child_)
            self.kinetics = obj_
            obj_.original_tagname_ = 'kinetics'
        elif nodeName_ == 'phDependence':
            obj_ = phDependenceType.factory()
            obj_.build(child_)
            self.phDependence = obj_
            obj_.original_tagname_ = 'phDependence'
        elif nodeName_ == 'redoxPotential':
            obj_ = redoxPotentialType.factory()
            obj_.build(child_)
            self.redoxPotential = obj_
            obj_.original_tagname_ = 'redoxPotential'
        elif nodeName_ == 'temperatureDependence':
            obj_ = temperatureDependenceType.factory()
            obj_.build(child_)
            self.temperatureDependence = obj_
            obj_.original_tagname_ = 'temperatureDependence'
        elif nodeName_ == 'cofactor':
            obj_ = cofactorType.factory()
            obj_.build(child_)
            self.cofactor.append(obj_)
            obj_.original_tagname_ = 'cofactor'
        elif nodeName_ == 'subcellularLocation':
            obj_ = subcellularLocationType.factory()
            obj_.build(child_)
            self.subcellularLocation.append(obj_)
            obj_.original_tagname_ = 'subcellularLocation'
        elif nodeName_ == 'conflict':
            obj_ = conflictType.factory()
            obj_.build(child_)
            self.conflict = obj_
            obj_.original_tagname_ = 'conflict'
        elif nodeName_ == 'link':
            obj_ = linkType.factory()
            obj_.build(child_)
            self.link.append(obj_)
            obj_.original_tagname_ = 'link'
        elif nodeName_ == 'event':
            obj_ = eventType.factory()
            obj_.build(child_)
            self.event.append(obj_)
            obj_.original_tagname_ = 'event'
        elif nodeName_ == 'isoform':
            obj_ = isoformType.factory()
            obj_.build(child_)
            self.isoform.append(obj_)
            obj_.original_tagname_ = 'isoform'
        elif nodeName_ == 'interactant':
            obj_ = interactantType.factory()
            obj_.build(child_)
            self.interactant.append(obj_)
            obj_.original_tagname_ = 'interactant'
        elif nodeName_ == 'organismsDiffer':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'organismsDiffer')
            self.organismsDiffer = ival_
        elif nodeName_ == 'experiments':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'experiments')
            self.experiments = ival_
        elif nodeName_ == 'disease':
            obj_ = diseaseType.factory()
            obj_.build(child_)
            self.disease = obj_
            obj_.original_tagname_ = 'disease'
        elif nodeName_ == 'location':
            obj_ = locationType.factory()
            obj_.build(child_)
            self.location.append(obj_)
            obj_.original_tagname_ = 'location'
        elif nodeName_ == 'text':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.text.append(obj_)
            obj_.original_tagname_ = 'text'
# end class commentType


class cofactorType(GeneratedsSuper):
    """Describes a cofactor."""
    subclass = None
    superclass = None
    def __init__(self, evidence=None, name=None, dbReference=None):
        self.original_tagname_ = None
        self.evidence = _cast(None, evidence)
        self.name = name
        self.dbReference = dbReference
    def factory(*args_, **kwargs_):
        if cofactorType.subclass:
            return cofactorType.subclass(*args_, **kwargs_)
        else:
            return cofactorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_dbReference(self): return self.dbReference
    def set_dbReference(self, dbReference): self.dbReference = dbReference
    def get_evidence(self): return self.evidence
    def set_evidence(self, evidence): self.evidence = evidence
    def validate_intListType(self, value):
        # Validate type intListType, a restriction on xs:int.
        pass
    def hasContent_(self):
        if (
            self.name is not None or
            self.dbReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cofactorType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cofactorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cofactorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cofactorType'):
        if self.evidence is not None and 'evidence' not in already_processed:
            already_processed.add('evidence')
            outfile.write(' evidence=%s' % (quote_attrib(self.evidence), ))
    def exportChildren(self, outfile, level, namespace_='', name_='cofactorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.dbReference is not None:
            self.dbReference.export(outfile, level, namespace_, name_='dbReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('evidence', node)
        if value is not None and 'evidence' not in already_processed:
            already_processed.add('evidence')
            try:
                self.evidence = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_intListType(self.evidence)    # validate type intListType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'dbReference':
            obj_ = dbReferenceType.factory()
            obj_.build(child_)
            self.dbReference = obj_
            obj_.original_tagname_ = 'dbReference'
# end class cofactorType


class subcellularLocationType(GeneratedsSuper):
    """Describes the subcellular location and optionally the topology and
    orientation of a molecule."""
    subclass = None
    superclass = None
    def __init__(self, location=None, topology=None, orientation=None):
        self.original_tagname_ = None
        if location is None:
            self.location = []
        else:
            self.location = location
        if topology is None:
            self.topology = []
        else:
            self.topology = topology
        if orientation is None:
            self.orientation = []
        else:
            self.orientation = orientation
    def factory(*args_, **kwargs_):
        if subcellularLocationType.subclass:
            return subcellularLocationType.subclass(*args_, **kwargs_)
        else:
            return subcellularLocationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_location(self): return self.location
    def set_location(self, location): self.location = location
    def add_location(self, value): self.location.append(value)
    def insert_location_at(self, index, value): self.location.insert(index, value)
    def replace_location_at(self, index, value): self.location[index] = value
    def get_topology(self): return self.topology
    def set_topology(self, topology): self.topology = topology
    def add_topology(self, value): self.topology.append(value)
    def insert_topology_at(self, index, value): self.topology.insert(index, value)
    def replace_topology_at(self, index, value): self.topology[index] = value
    def get_orientation(self): return self.orientation
    def set_orientation(self, orientation): self.orientation = orientation
    def add_orientation(self, value): self.orientation.append(value)
    def insert_orientation_at(self, index, value): self.orientation.insert(index, value)
    def replace_orientation_at(self, index, value): self.orientation[index] = value
    def hasContent_(self):
        if (
            self.location or
            self.topology or
            self.orientation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='subcellularLocationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='subcellularLocationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='subcellularLocationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='subcellularLocationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='subcellularLocationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for location_ in self.location:
            location_.export(outfile, level, namespace_, name_='location', pretty_print=pretty_print)
        for topology_ in self.topology:
            topology_.export(outfile, level, namespace_, name_='topology', pretty_print=pretty_print)
        for orientation_ in self.orientation:
            orientation_.export(outfile, level, namespace_, name_='orientation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'location':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.location.append(obj_)
            obj_.original_tagname_ = 'location'
        elif nodeName_ == 'topology':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.topology.append(obj_)
            obj_.original_tagname_ = 'topology'
        elif nodeName_ == 'orientation':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.orientation.append(obj_)
            obj_.original_tagname_ = 'orientation'
# end class subcellularLocationType


class eventType(GeneratedsSuper):
    """Describes the type of events that cause alternative products."""
    subclass = None
    superclass = None
    def __init__(self, type_=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
    def factory(*args_, **kwargs_):
        if eventType.subclass:
            return eventType.subclass(*args_, **kwargs_)
        else:
            return eventType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='eventType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='eventType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='eventType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='eventType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='eventType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class eventType


class isoformType(GeneratedsSuper):
    """Describes isoforms in 'alternative products' annotations."""
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, sequence=None, text=None):
        self.original_tagname_ = None
        if id is None:
            self.id = []
        else:
            self.id = id
        if name is None:
            self.name = []
        else:
            self.name = name
        self.sequence = sequence
        if text is None:
            self.text = []
        else:
            self.text = text
    def factory(*args_, **kwargs_):
        if isoformType.subclass:
            return isoformType.subclass(*args_, **kwargs_)
        else:
            return isoformType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def add_id(self, value): self.id.append(value)
    def insert_id_at(self, index, value): self.id.insert(index, value)
    def replace_id_at(self, index, value): self.id[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def add_name(self, value): self.name.append(value)
    def insert_name_at(self, index, value): self.name.insert(index, value)
    def replace_name_at(self, index, value): self.name[index] = value
    def get_sequence(self): return self.sequence
    def set_sequence(self, sequence): self.sequence = sequence
    def get_text(self): return self.text
    def set_text(self, text): self.text = text
    def add_text(self, value): self.text.append(value)
    def insert_text_at(self, index, value): self.text.insert(index, value)
    def replace_text_at(self, index, value): self.text[index] = value
    def hasContent_(self):
        if (
            self.id or
            self.name or
            self.sequence is not None or
            self.text
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='isoformType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='isoformType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='isoformType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='isoformType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='isoformType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for id_ in self.id:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespace_, self.gds_format_string(quote_xml(id_).encode(ExternalEncoding), input_name='id'), namespace_, eol_))
        for name_ in self.name:
            name_.export(outfile, level, namespace_, name_='name', pretty_print=pretty_print)
        if self.sequence is not None:
            self.sequence.export(outfile, level, namespace_, name_='sequence', pretty_print=pretty_print)
        for text_ in self.text:
            text_.export(outfile, level, namespace_, name_='text', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'id':
            id_ = child_.text
            id_ = self.gds_validate_string(id_, node, 'id')
            self.id.append(id_)
        elif nodeName_ == 'name':
            obj_ = nameType.factory()
            obj_.build(child_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'sequence':
            obj_ = sequenceType16.factory()
            obj_.build(child_)
            self.sequence = obj_
            obj_.original_tagname_ = 'sequence'
        elif nodeName_ == 'text':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.text.append(obj_)
            obj_.original_tagname_ = 'text'
# end class isoformType


class interactantType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, intactId=None, id=None, label=None):
        self.original_tagname_ = None
        self.intactId = _cast(None, intactId)
        self.id = id
        self.label = label
    def factory(*args_, **kwargs_):
        if interactantType.subclass:
            return interactantType.subclass(*args_, **kwargs_)
        else:
            return interactantType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def get_intactId(self): return self.intactId
    def set_intactId(self, intactId): self.intactId = intactId
    def hasContent_(self):
        if (
            self.id is not None or
            self.label is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='interactantType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='interactantType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='interactantType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='interactantType'):
        if self.intactId is not None and 'intactId' not in already_processed:
            already_processed.add('intactId')
            outfile.write(' intactId=%s' % (self.gds_format_string(quote_attrib(self.intactId).encode(ExternalEncoding), input_name='intactId'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='interactantType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespace_, self.gds_format_string(quote_xml(self.id).encode(ExternalEncoding), input_name='id'), namespace_, eol_))
        if self.label is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slabel>%s</%slabel>%s' % (namespace_, self.gds_format_string(quote_xml(self.label).encode(ExternalEncoding), input_name='label'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('intactId', node)
        if value is not None and 'intactId' not in already_processed:
            already_processed.add('intactId')
            self.intactId = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'id':
            id_ = child_.text
            id_ = self.gds_validate_string(id_, node, 'id')
            self.id = id_
        elif nodeName_ == 'label':
            label_ = child_.text
            label_ = self.gds_validate_string(label_, node, 'label')
            self.label = label_
# end class interactantType


class dbReferenceType(GeneratedsSuper):
    """Describes a database cross-reference. Equivalent to the flat file
    DR-line. Describes the name of the database.Describes a unique
    database identifier."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, id=None, evidence=None, molecule=None, property=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.id = _cast(None, id)
        self.evidence = _cast(None, evidence)
        self.molecule = molecule
        if property is None:
            self.property = []
        else:
            self.property = property
    def factory(*args_, **kwargs_):
        if dbReferenceType.subclass:
            return dbReferenceType.subclass(*args_, **kwargs_)
        else:
            return dbReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_molecule(self): return self.molecule
    def set_molecule(self, molecule): self.molecule = molecule
    def get_property(self): return self.property
    def set_property(self, property): self.property = property
    def add_property(self, value): self.property.append(value)
    def insert_property_at(self, index, value): self.property.insert(index, value)
    def replace_property_at(self, index, value): self.property[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_evidence(self): return self.evidence
    def set_evidence(self, evidence): self.evidence = evidence
    def validate_intListType(self, value):
        # Validate type intListType, a restriction on xs:int.
        pass
    def hasContent_(self):
        if (
            self.molecule is not None or
            self.property
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='dbReferenceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dbReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='dbReferenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='dbReferenceType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.evidence is not None and 'evidence' not in already_processed:
            already_processed.add('evidence')
            outfile.write(' evidence=%s' % (quote_attrib(self.evidence), ))
    def exportChildren(self, outfile, level, namespace_='', name_='dbReferenceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.molecule is not None:
            self.molecule.export(outfile, level, namespace_, name_='molecule', pretty_print=pretty_print)
        for property_ in self.property:
            property_.export(outfile, level, namespace_, name_='property', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('evidence', node)
        if value is not None and 'evidence' not in already_processed:
            already_processed.add('evidence')
            try:
                self.evidence = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_intListType(self.evidence)    # validate type intListType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'molecule':
            obj_ = moleculeType.factory()
            obj_.build(child_)
            self.molecule = obj_
            obj_.original_tagname_ = 'molecule'
        elif nodeName_ == 'property':
            obj_ = propertyType.factory()
            obj_.build(child_)
            self.property.append(obj_)
            obj_.original_tagname_ = 'property'
# end class dbReferenceType


class propertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, value=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.value = _cast(None, value)
    def factory(*args_, **kwargs_):
        if propertyType.subclass:
            return propertyType.subclass(*args_, **kwargs_)
        else:
            return propertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='propertyType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='propertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='propertyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='propertyType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='propertyType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class propertyType


class proteinExistenceType(GeneratedsSuper):
    """Describes the evidence for the protein's existence. Equivalent to
    the flat file PE-line."""
    subclass = None
    superclass = None
    def __init__(self, type_=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
    def factory(*args_, **kwargs_):
        if proteinExistenceType.subclass:
            return proteinExistenceType.subclass(*args_, **kwargs_)
        else:
            return proteinExistenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='proteinExistenceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='proteinExistenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='proteinExistenceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='proteinExistenceType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='proteinExistenceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class proteinExistenceType


class keywordType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, evidence=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.evidence = _cast(None, evidence)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if keywordType.subclass:
            return keywordType.subclass(*args_, **kwargs_)
        else:
            return keywordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_evidence(self): return self.evidence
    def set_evidence(self, evidence): self.evidence = evidence
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_intListType(self, value):
        # Validate type intListType, a restriction on xs:int.
        pass
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='keywordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='keywordType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='keywordType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='keywordType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.evidence is not None and 'evidence' not in already_processed:
            already_processed.add('evidence')
            outfile.write(' evidence=%s' % (quote_attrib(self.evidence), ))
    def exportChildren(self, outfile, level, namespace_='', name_='keywordType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('evidence', node)
        if value is not None and 'evidence' not in already_processed:
            already_processed.add('evidence')
            try:
                self.evidence = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_intListType(self.evidence)    # validate type intListType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class keywordType


class featureType(GeneratedsSuper):
    """Describes different types of sequence annotations. Equivalent to the
    flat file FT-line.Describes the type of a sequence annotation.
    Equivalent to the flat file FT feature keys, but using full
    terms instead of acronyms."""
    subclass = None
    superclass = None
    def __init__(self, status=None, description=None, type_=None, evidence=None, ref=None, id=None, original=None, variation=None, location=None):
        self.original_tagname_ = None
        self.status = _cast(None, status)
        self.description = _cast(None, description)
        self.type_ = _cast(None, type_)
        self.evidence = _cast(None, evidence)
        self.ref = _cast(None, ref)
        self.id = _cast(None, id)
        self.original = original
        if variation is None:
            self.variation = []
        else:
            self.variation = variation
        self.location = location
    def factory(*args_, **kwargs_):
        if featureType.subclass:
            return featureType.subclass(*args_, **kwargs_)
        else:
            return featureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_original(self): return self.original
    def set_original(self, original): self.original = original
    def get_variation(self): return self.variation
    def set_variation(self, variation): self.variation = variation
    def add_variation(self, value): self.variation.append(value)
    def insert_variation_at(self, index, value): self.variation.insert(index, value)
    def replace_variation_at(self, index, value): self.variation[index] = value
    def get_location(self): return self.location
    def set_location(self, location): self.location = location
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_evidence(self): return self.evidence
    def set_evidence(self, evidence): self.evidence = evidence
    def get_ref(self): return self.ref
    def set_ref(self, ref): self.ref = ref
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_intListType(self, value):
        # Validate type intListType, a restriction on xs:int.
        pass
    def hasContent_(self):
        if (
            self.original is not None or
            self.variation or
            self.location is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='featureType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='featureType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='featureType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='featureType'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (self.gds_format_string(quote_attrib(self.status).encode(ExternalEncoding), input_name='status'), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_format_string(quote_attrib(self.description).encode(ExternalEncoding), input_name='description'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.evidence is not None and 'evidence' not in already_processed:
            already_processed.add('evidence')
            outfile.write(' evidence=%s' % (quote_attrib(self.evidence), ))
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_format_string(quote_attrib(self.ref).encode(ExternalEncoding), input_name='ref'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='featureType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soriginal>%s</%soriginal>%s' % (namespace_, self.gds_format_string(quote_xml(self.original).encode(ExternalEncoding), input_name='original'), namespace_, eol_))
        for variation_ in self.variation:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svariation>%s</%svariation>%s' % (namespace_, self.gds_format_string(quote_xml(variation_).encode(ExternalEncoding), input_name='variation'), namespace_, eol_))
        if self.location is not None:
            self.location.export(outfile, level, namespace_, name_='location', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('evidence', node)
        if value is not None and 'evidence' not in already_processed:
            already_processed.add('evidence')
            try:
                self.evidence = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_intListType(self.evidence)    # validate type intListType
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'original':
            original_ = child_.text
            original_ = self.gds_validate_string(original_, node, 'original')
            self.original = original_
        elif nodeName_ == 'variation':
            variation_ = child_.text
            variation_ = self.gds_validate_string(variation_, node, 'variation')
            self.variation.append(variation_)
        elif nodeName_ == 'location':
            obj_ = locationType.factory()
            obj_.build(child_)
            self.location = obj_
            obj_.original_tagname_ = 'location'
# end class featureType


class locationType(GeneratedsSuper):
    """Describes a sequence location as either a range with a begin and end
    or as a position. The 'sequence' attribute is only used when the
    location is not on the canonical sequence displayed in the
    current entry."""
    subclass = None
    superclass = None
    def __init__(self, sequence=None, begin=None, end=None, position=None):
        self.original_tagname_ = None
        self.sequence = _cast(None, sequence)
        self.begin = begin
        self.end = end
        self.position = position
    def factory(*args_, **kwargs_):
        if locationType.subclass:
            return locationType.subclass(*args_, **kwargs_)
        else:
            return locationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_begin(self): return self.begin
    def set_begin(self, begin): self.begin = begin
    def get_end(self): return self.end
    def set_end(self, end): self.end = end
    def get_position(self): return self.position
    def set_position(self, position): self.position = position
    def get_sequence(self): return self.sequence
    def set_sequence(self, sequence): self.sequence = sequence
    def hasContent_(self):
        if (
            self.begin is not None or
            self.end is not None or
            self.position is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='locationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='locationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='locationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='locationType'):
        if self.sequence is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            outfile.write(' sequence=%s' % (self.gds_format_string(quote_attrib(self.sequence).encode(ExternalEncoding), input_name='sequence'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='locationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.begin is not None:
            self.begin.export(outfile, level, namespace_, name_='begin', pretty_print=pretty_print)
        if self.end is not None:
            self.end.export(outfile, level, namespace_, name_='end', pretty_print=pretty_print)
        if self.position is not None:
            self.position.export(outfile, level, namespace_, name_='position', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sequence', node)
        if value is not None and 'sequence' not in already_processed:
            already_processed.add('sequence')
            self.sequence = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'begin':
            obj_ = positionType.factory()
            obj_.build(child_)
            self.begin = obj_
            obj_.original_tagname_ = 'begin'
        elif nodeName_ == 'end':
            obj_ = positionType.factory()
            obj_.build(child_)
            self.end = obj_
            obj_.original_tagname_ = 'end'
        elif nodeName_ == 'position':
            obj_ = positionType.factory()
            obj_.build(child_)
            self.position = obj_
            obj_.original_tagname_ = 'position'
# end class locationType


class positionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, status='certain', position=None, evidence=None):
        self.original_tagname_ = None
        self.status = _cast(None, status)
        self.position = _cast(int, position)
        self.evidence = _cast(None, evidence)
    def factory(*args_, **kwargs_):
        if positionType.subclass:
            return positionType.subclass(*args_, **kwargs_)
        else:
            return positionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_position(self): return self.position
    def set_position(self, position): self.position = position
    def get_evidence(self): return self.evidence
    def set_evidence(self, evidence): self.evidence = evidence
    def validate_intListType(self, value):
        # Validate type intListType, a restriction on xs:int.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='positionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='positionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='positionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='positionType'):
        if self.status != "certain" and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (self.gds_format_string(quote_attrib(self.status).encode(ExternalEncoding), input_name='status'), ))
        if self.position is not None and 'position' not in already_processed:
            already_processed.add('position')
            outfile.write(' position="%s"' % self.gds_format_integer(self.position, input_name='position'))
        if self.evidence is not None and 'evidence' not in already_processed:
            already_processed.add('evidence')
            outfile.write(' evidence=%s' % (quote_attrib(self.evidence), ))
    def exportChildren(self, outfile, level, namespace_='', name_='positionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
        value = find_attr_value_('position', node)
        if value is not None and 'position' not in already_processed:
            already_processed.add('position')
            try:
                self.position = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('evidence', node)
        if value is not None and 'evidence' not in already_processed:
            already_processed.add('evidence')
            try:
                self.evidence = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_intListType(self.evidence)    # validate type intListType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class positionType


class sequenceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, precursor=None, checksum=None, modified=None, fragment=None, length=None, version=None, mass=None, valueOf_=None):
        self.original_tagname_ = None
        self.precursor = _cast(bool, precursor)
        self.checksum = _cast(None, checksum)
        if isinstance(modified, basestring):
            initvalue_ = datetime_.datetime.strptime(modified, '%Y-%m-%d').date()
        else:
            initvalue_ = modified
        self.modified = initvalue_
        self.fragment = _cast(None, fragment)
        self.length = _cast(int, length)
        self.version = _cast(int, version)
        self.mass = _cast(int, mass)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if sequenceType.subclass:
            return sequenceType.subclass(*args_, **kwargs_)
        else:
            return sequenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_precursor(self): return self.precursor
    def set_precursor(self, precursor): self.precursor = precursor
    def get_checksum(self): return self.checksum
    def set_checksum(self, checksum): self.checksum = checksum
    def get_modified(self): return self.modified
    def set_modified(self, modified): self.modified = modified
    def get_fragment(self): return self.fragment
    def set_fragment(self, fragment): self.fragment = fragment
    def get_length(self): return self.length
    def set_length(self, length): self.length = length
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_mass(self): return self.mass
    def set_mass(self, mass): self.mass = mass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='sequenceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sequenceType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='sequenceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='sequenceType'):
        if self.precursor is not None and 'precursor' not in already_processed:
            already_processed.add('precursor')
            outfile.write(' precursor="%s"' % self.gds_format_boolean(self.precursor, input_name='precursor'))
        if self.checksum is not None and 'checksum' not in already_processed:
            already_processed.add('checksum')
            outfile.write(' checksum=%s' % (self.gds_format_string(quote_attrib(self.checksum).encode(ExternalEncoding), input_name='checksum'), ))
        if self.modified is not None and 'modified' not in already_processed:
            already_processed.add('modified')
            outfile.write(' modified="%s"' % self.gds_format_date(self.modified, input_name='modified'))
        if self.fragment is not None and 'fragment' not in already_processed:
            already_processed.add('fragment')
            outfile.write(' fragment=%s' % (self.gds_format_string(quote_attrib(self.fragment).encode(ExternalEncoding), input_name='fragment'), ))
        if self.length is not None and 'length' not in already_processed:
            already_processed.add('length')
            outfile.write(' length="%s"' % self.gds_format_integer(self.length, input_name='length'))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version="%s"' % self.gds_format_integer(self.version, input_name='version'))
        if self.mass is not None and 'mass' not in already_processed:
            already_processed.add('mass')
            outfile.write(' mass="%s"' % self.gds_format_integer(self.mass, input_name='mass'))
    def exportChildren(self, outfile, level, namespace_='', name_='sequenceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('precursor', node)
        if value is not None and 'precursor' not in already_processed:
            already_processed.add('precursor')
            if value in ('true', '1'):
                self.precursor = True
            elif value in ('false', '0'):
                self.precursor = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('checksum', node)
        if value is not None and 'checksum' not in already_processed:
            already_processed.add('checksum')
            self.checksum = value
        value = find_attr_value_('modified', node)
        if value is not None and 'modified' not in already_processed:
            already_processed.add('modified')
            try:
                self.modified = self.gds_parse_date(value)
            except ValueError as exp:
                raise ValueError('Bad date attribute (modified): %s' % exp)
        value = find_attr_value_('fragment', node)
        if value is not None and 'fragment' not in already_processed:
            already_processed.add('fragment')
            self.fragment = value
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.add('length')
            try:
                self.length = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            try:
                self.version = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('mass', node)
        if value is not None and 'mass' not in already_processed:
            already_processed.add('mass')
            try:
                self.mass = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class sequenceType


class moleculeType(GeneratedsSuper):
    """Describes a molecule by name or unique identifier."""
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if moleculeType.subclass:
            return moleculeType.subclass(*args_, **kwargs_)
        else:
            return moleculeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='moleculeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='moleculeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='moleculeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='moleculeType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='moleculeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class moleculeType


class evidenceType(GeneratedsSuper):
    """Describes the evidence for an annotation. No flat file
    equivalent.Describes the type of an evidence using the Evidence
    Code Ontology (http://www.obofoundry.org/cgi-
    bin/detail.cgi?id=evidence_code).A unique key to link
    annotations (via 'evidence' attributes) to evidences."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, key=None, source=None, importedFrom=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.key = _cast(int, key)
        self.source = source
        self.importedFrom = importedFrom
    def factory(*args_, **kwargs_):
        if evidenceType.subclass:
            return evidenceType.subclass(*args_, **kwargs_)
        else:
            return evidenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_importedFrom(self): return self.importedFrom
    def set_importedFrom(self, importedFrom): self.importedFrom = importedFrom
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def hasContent_(self):
        if (
            self.source is not None or
            self.importedFrom is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='evidenceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='evidenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='evidenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='evidenceType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.key is not None and 'key' not in already_processed:
            already_processed.add('key')
            outfile.write(' key="%s"' % self.gds_format_integer(self.key, input_name='key'))
    def exportChildren(self, outfile, level, namespace_='', name_='evidenceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.source is not None:
            self.source.export(outfile, level, namespace_, name_='source', pretty_print=pretty_print)
        if self.importedFrom is not None:
            self.importedFrom.export(outfile, level, namespace_, name_='importedFrom', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('key', node)
        if value is not None and 'key' not in already_processed:
            already_processed.add('key')
            try:
                self.key = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'source':
            obj_ = sourceType.factory()
            obj_.build(child_)
            self.source = obj_
            obj_.original_tagname_ = 'source'
        elif nodeName_ == 'importedFrom':
            obj_ = importedFromType.factory()
            obj_.build(child_)
            self.importedFrom = obj_
            obj_.original_tagname_ = 'importedFrom'
# end class evidenceType


class sourceType(GeneratedsSuper):
    """Describes the source of the data using a database cross-reference
    (or a 'ref' attribute when the source cannot be found in a
    public data source, such as PubMed, and is cited only within the
    UniProtKB entry)."""
    subclass = None
    superclass = None
    def __init__(self, ref=None, dbReference=None):
        self.original_tagname_ = None
        self.ref = _cast(int, ref)
        self.dbReference = dbReference
    def factory(*args_, **kwargs_):
        if sourceType.subclass:
            return sourceType.subclass(*args_, **kwargs_)
        else:
            return sourceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dbReference(self): return self.dbReference
    def set_dbReference(self, dbReference): self.dbReference = dbReference
    def get_ref(self): return self.ref
    def set_ref(self, ref): self.ref = ref
    def hasContent_(self):
        if (
            self.dbReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='sourceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sourceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='sourceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='sourceType'):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref="%s"' % self.gds_format_integer(self.ref, input_name='ref'))
    def exportChildren(self, outfile, level, namespace_='', name_='sourceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dbReference is not None:
            self.dbReference.export(outfile, level, namespace_, name_='dbReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            try:
                self.ref = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dbReference':
            obj_ = dbReferenceType.factory()
            obj_.build(child_)
            self.dbReference = obj_
            obj_.original_tagname_ = 'dbReference'
# end class sourceType


class importedFromType(GeneratedsSuper):
    """Describes the source of the evidence, when it is not assigned by
    UniProt, but imported from an external database."""
    subclass = None
    superclass = None
    def __init__(self, dbReference=None):
        self.original_tagname_ = None
        self.dbReference = dbReference
    def factory(*args_, **kwargs_):
        if importedFromType.subclass:
            return importedFromType.subclass(*args_, **kwargs_)
        else:
            return importedFromType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dbReference(self): return self.dbReference
    def set_dbReference(self, dbReference): self.dbReference = dbReference
    def hasContent_(self):
        if (
            self.dbReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='importedFromType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='importedFromType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='importedFromType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='importedFromType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='importedFromType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dbReference is not None:
            self.dbReference.export(outfile, level, namespace_, name_='dbReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dbReference':
            obj_ = dbReferenceType.factory()
            obj_.build(child_)
            self.dbReference = obj_
            obj_.original_tagname_ = 'dbReference'
# end class importedFromType


class evidencedStringType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, status=None, evidence=None, valueOf_=None):
        self.original_tagname_ = None
        self.status = _cast(None, status)
        self.evidence = _cast(None, evidence)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if evidencedStringType.subclass:
            return evidencedStringType.subclass(*args_, **kwargs_)
        else:
            return evidencedStringType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_evidence(self): return self.evidence
    def set_evidence(self, evidence): self.evidence = evidence
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_intListType(self, value):
        # Validate type intListType, a restriction on xs:int.
        pass
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='evidencedStringType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='evidencedStringType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='evidencedStringType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='evidencedStringType'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (self.gds_format_string(quote_attrib(self.status).encode(ExternalEncoding), input_name='status'), ))
        if self.evidence is not None and 'evidence' not in already_processed:
            already_processed.add('evidence')
            outfile.write(' evidence=%s' % (quote_attrib(self.evidence), ))
    def exportChildren(self, outfile, level, namespace_='', name_='evidencedStringType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
        value = find_attr_value_('evidence', node)
        if value is not None and 'evidence' not in already_processed:
            already_processed.add('evidence')
            try:
                self.evidence = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_intListType(self.evidence)    # validate type intListType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class evidencedStringType


class recommendedNameType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, fullName=None, shortName=None, ecNumber=None):
        self.original_tagname_ = None
        self.fullName = fullName
        if shortName is None:
            self.shortName = []
        else:
            self.shortName = shortName
        if ecNumber is None:
            self.ecNumber = []
        else:
            self.ecNumber = ecNumber
    def factory(*args_, **kwargs_):
        if recommendedNameType.subclass:
            return recommendedNameType.subclass(*args_, **kwargs_)
        else:
            return recommendedNameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fullName(self): return self.fullName
    def set_fullName(self, fullName): self.fullName = fullName
    def get_shortName(self): return self.shortName
    def set_shortName(self, shortName): self.shortName = shortName
    def add_shortName(self, value): self.shortName.append(value)
    def insert_shortName_at(self, index, value): self.shortName.insert(index, value)
    def replace_shortName_at(self, index, value): self.shortName[index] = value
    def get_ecNumber(self): return self.ecNumber
    def set_ecNumber(self, ecNumber): self.ecNumber = ecNumber
    def add_ecNumber(self, value): self.ecNumber.append(value)
    def insert_ecNumber_at(self, index, value): self.ecNumber.insert(index, value)
    def replace_ecNumber_at(self, index, value): self.ecNumber[index] = value
    def hasContent_(self):
        if (
            self.fullName is not None or
            self.shortName or
            self.ecNumber
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='recommendedNameType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='recommendedNameType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='recommendedNameType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='recommendedNameType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='recommendedNameType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fullName is not None:
            self.fullName.export(outfile, level, namespace_, name_='fullName', pretty_print=pretty_print)
        for shortName_ in self.shortName:
            shortName_.export(outfile, level, namespace_, name_='shortName', pretty_print=pretty_print)
        for ecNumber_ in self.ecNumber:
            ecNumber_.export(outfile, level, namespace_, name_='ecNumber', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fullName':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.fullName = obj_
            obj_.original_tagname_ = 'fullName'
        elif nodeName_ == 'shortName':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.shortName.append(obj_)
            obj_.original_tagname_ = 'shortName'
        elif nodeName_ == 'ecNumber':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.ecNumber.append(obj_)
            obj_.original_tagname_ = 'ecNumber'
# end class recommendedNameType


class alternativeNameType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, fullName=None, shortName=None, ecNumber=None):
        self.original_tagname_ = None
        self.fullName = fullName
        if shortName is None:
            self.shortName = []
        else:
            self.shortName = shortName
        if ecNumber is None:
            self.ecNumber = []
        else:
            self.ecNumber = ecNumber
    def factory(*args_, **kwargs_):
        if alternativeNameType.subclass:
            return alternativeNameType.subclass(*args_, **kwargs_)
        else:
            return alternativeNameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fullName(self): return self.fullName
    def set_fullName(self, fullName): self.fullName = fullName
    def get_shortName(self): return self.shortName
    def set_shortName(self, shortName): self.shortName = shortName
    def add_shortName(self, value): self.shortName.append(value)
    def insert_shortName_at(self, index, value): self.shortName.insert(index, value)
    def replace_shortName_at(self, index, value): self.shortName[index] = value
    def get_ecNumber(self): return self.ecNumber
    def set_ecNumber(self, ecNumber): self.ecNumber = ecNumber
    def add_ecNumber(self, value): self.ecNumber.append(value)
    def insert_ecNumber_at(self, index, value): self.ecNumber.insert(index, value)
    def replace_ecNumber_at(self, index, value): self.ecNumber[index] = value
    def hasContent_(self):
        if (
            self.fullName is not None or
            self.shortName or
            self.ecNumber
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='alternativeNameType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='alternativeNameType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='alternativeNameType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='alternativeNameType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='alternativeNameType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fullName is not None:
            self.fullName.export(outfile, level, namespace_, name_='fullName', pretty_print=pretty_print)
        for shortName_ in self.shortName:
            shortName_.export(outfile, level, namespace_, name_='shortName', pretty_print=pretty_print)
        for ecNumber_ in self.ecNumber:
            ecNumber_.export(outfile, level, namespace_, name_='ecNumber', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fullName':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.fullName = obj_
            obj_.original_tagname_ = 'fullName'
        elif nodeName_ == 'shortName':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.shortName.append(obj_)
            obj_.original_tagname_ = 'shortName'
        elif nodeName_ == 'ecNumber':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.ecNumber.append(obj_)
            obj_.original_tagname_ = 'ecNumber'
# end class alternativeNameType


class submittedNameType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, fullName=None, ecNumber=None):
        self.original_tagname_ = None
        self.fullName = fullName
        if ecNumber is None:
            self.ecNumber = []
        else:
            self.ecNumber = ecNumber
    def factory(*args_, **kwargs_):
        if submittedNameType.subclass:
            return submittedNameType.subclass(*args_, **kwargs_)
        else:
            return submittedNameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fullName(self): return self.fullName
    def set_fullName(self, fullName): self.fullName = fullName
    def get_ecNumber(self): return self.ecNumber
    def set_ecNumber(self, ecNumber): self.ecNumber = ecNumber
    def add_ecNumber(self, value): self.ecNumber.append(value)
    def insert_ecNumber_at(self, index, value): self.ecNumber.insert(index, value)
    def replace_ecNumber_at(self, index, value): self.ecNumber[index] = value
    def hasContent_(self):
        if (
            self.fullName is not None or
            self.ecNumber
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='submittedNameType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='submittedNameType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='submittedNameType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='submittedNameType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='submittedNameType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fullName is not None:
            self.fullName.export(outfile, level, namespace_, name_='fullName', pretty_print=pretty_print)
        for ecNumber_ in self.ecNumber:
            ecNumber_.export(outfile, level, namespace_, name_='ecNumber', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fullName':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.fullName = obj_
            obj_.original_tagname_ = 'fullName'
        elif nodeName_ == 'ecNumber':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.ecNumber.append(obj_)
            obj_.original_tagname_ = 'ecNumber'
# end class submittedNameType


class domainType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, recommendedName=None, alternativeName=None, submittedName=None, allergenName=None, biotechName=None, cdAntigenName=None, innName=None):
        self.original_tagname_ = None
        self.recommendedName = recommendedName
        if alternativeName is None:
            self.alternativeName = []
        else:
            self.alternativeName = alternativeName
        if submittedName is None:
            self.submittedName = []
        else:
            self.submittedName = submittedName
        self.allergenName = allergenName
        self.biotechName = biotechName
        if cdAntigenName is None:
            self.cdAntigenName = []
        else:
            self.cdAntigenName = cdAntigenName
        if innName is None:
            self.innName = []
        else:
            self.innName = innName
    def factory(*args_, **kwargs_):
        if domainType.subclass:
            return domainType.subclass(*args_, **kwargs_)
        else:
            return domainType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_recommendedName(self): return self.recommendedName
    def set_recommendedName(self, recommendedName): self.recommendedName = recommendedName
    def get_alternativeName(self): return self.alternativeName
    def set_alternativeName(self, alternativeName): self.alternativeName = alternativeName
    def add_alternativeName(self, value): self.alternativeName.append(value)
    def insert_alternativeName_at(self, index, value): self.alternativeName.insert(index, value)
    def replace_alternativeName_at(self, index, value): self.alternativeName[index] = value
    def get_submittedName(self): return self.submittedName
    def set_submittedName(self, submittedName): self.submittedName = submittedName
    def add_submittedName(self, value): self.submittedName.append(value)
    def insert_submittedName_at(self, index, value): self.submittedName.insert(index, value)
    def replace_submittedName_at(self, index, value): self.submittedName[index] = value
    def get_allergenName(self): return self.allergenName
    def set_allergenName(self, allergenName): self.allergenName = allergenName
    def get_biotechName(self): return self.biotechName
    def set_biotechName(self, biotechName): self.biotechName = biotechName
    def get_cdAntigenName(self): return self.cdAntigenName
    def set_cdAntigenName(self, cdAntigenName): self.cdAntigenName = cdAntigenName
    def add_cdAntigenName(self, value): self.cdAntigenName.append(value)
    def insert_cdAntigenName_at(self, index, value): self.cdAntigenName.insert(index, value)
    def replace_cdAntigenName_at(self, index, value): self.cdAntigenName[index] = value
    def get_innName(self): return self.innName
    def set_innName(self, innName): self.innName = innName
    def add_innName(self, value): self.innName.append(value)
    def insert_innName_at(self, index, value): self.innName.insert(index, value)
    def replace_innName_at(self, index, value): self.innName[index] = value
    def hasContent_(self):
        if (
            self.recommendedName is not None or
            self.alternativeName or
            self.submittedName or
            self.allergenName is not None or
            self.biotechName is not None or
            self.cdAntigenName or
            self.innName
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='domainType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='domainType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='domainType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='domainType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='domainType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.recommendedName is not None:
            self.recommendedName.export(outfile, level, namespace_, name_='recommendedName', pretty_print=pretty_print)
        for alternativeName_ in self.alternativeName:
            alternativeName_.export(outfile, level, namespace_, name_='alternativeName', pretty_print=pretty_print)
        for submittedName_ in self.submittedName:
            submittedName_.export(outfile, level, namespace_, name_='submittedName', pretty_print=pretty_print)
        if self.allergenName is not None:
            self.allergenName.export(outfile, level, namespace_, name_='allergenName', pretty_print=pretty_print)
        if self.biotechName is not None:
            self.biotechName.export(outfile, level, namespace_, name_='biotechName', pretty_print=pretty_print)
        for cdAntigenName_ in self.cdAntigenName:
            cdAntigenName_.export(outfile, level, namespace_, name_='cdAntigenName', pretty_print=pretty_print)
        for innName_ in self.innName:
            innName_.export(outfile, level, namespace_, name_='innName', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'recommendedName':
            obj_ = recommendedNameType1.factory()
            obj_.build(child_)
            self.recommendedName = obj_
            obj_.original_tagname_ = 'recommendedName'
        elif nodeName_ == 'alternativeName':
            obj_ = alternativeNameType2.factory()
            obj_.build(child_)
            self.alternativeName.append(obj_)
            obj_.original_tagname_ = 'alternativeName'
        elif nodeName_ == 'submittedName':
            obj_ = submittedNameType3.factory()
            obj_.build(child_)
            self.submittedName.append(obj_)
            obj_.original_tagname_ = 'submittedName'
        elif nodeName_ == 'allergenName':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.allergenName = obj_
            obj_.original_tagname_ = 'allergenName'
        elif nodeName_ == 'biotechName':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.biotechName = obj_
            obj_.original_tagname_ = 'biotechName'
        elif nodeName_ == 'cdAntigenName':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.cdAntigenName.append(obj_)
            obj_.original_tagname_ = 'cdAntigenName'
        elif nodeName_ == 'innName':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.innName.append(obj_)
            obj_.original_tagname_ = 'innName'
# end class domainType


class recommendedNameType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, fullName=None, shortName=None, ecNumber=None):
        self.original_tagname_ = None
        self.fullName = fullName
        if shortName is None:
            self.shortName = []
        else:
            self.shortName = shortName
        if ecNumber is None:
            self.ecNumber = []
        else:
            self.ecNumber = ecNumber
    def factory(*args_, **kwargs_):
        if recommendedNameType1.subclass:
            return recommendedNameType1.subclass(*args_, **kwargs_)
        else:
            return recommendedNameType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fullName(self): return self.fullName
    def set_fullName(self, fullName): self.fullName = fullName
    def get_shortName(self): return self.shortName
    def set_shortName(self, shortName): self.shortName = shortName
    def add_shortName(self, value): self.shortName.append(value)
    def insert_shortName_at(self, index, value): self.shortName.insert(index, value)
    def replace_shortName_at(self, index, value): self.shortName[index] = value
    def get_ecNumber(self): return self.ecNumber
    def set_ecNumber(self, ecNumber): self.ecNumber = ecNumber
    def add_ecNumber(self, value): self.ecNumber.append(value)
    def insert_ecNumber_at(self, index, value): self.ecNumber.insert(index, value)
    def replace_ecNumber_at(self, index, value): self.ecNumber[index] = value
    def hasContent_(self):
        if (
            self.fullName is not None or
            self.shortName or
            self.ecNumber
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='recommendedNameType1', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='recommendedNameType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='recommendedNameType1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='recommendedNameType1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='recommendedNameType1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fullName is not None:
            self.fullName.export(outfile, level, namespace_, name_='fullName', pretty_print=pretty_print)
        for shortName_ in self.shortName:
            shortName_.export(outfile, level, namespace_, name_='shortName', pretty_print=pretty_print)
        for ecNumber_ in self.ecNumber:
            ecNumber_.export(outfile, level, namespace_, name_='ecNumber', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fullName':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.fullName = obj_
            obj_.original_tagname_ = 'fullName'
        elif nodeName_ == 'shortName':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.shortName.append(obj_)
            obj_.original_tagname_ = 'shortName'
        elif nodeName_ == 'ecNumber':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.ecNumber.append(obj_)
            obj_.original_tagname_ = 'ecNumber'
# end class recommendedNameType1


class alternativeNameType2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, fullName=None, shortName=None, ecNumber=None):
        self.original_tagname_ = None
        self.fullName = fullName
        if shortName is None:
            self.shortName = []
        else:
            self.shortName = shortName
        if ecNumber is None:
            self.ecNumber = []
        else:
            self.ecNumber = ecNumber
    def factory(*args_, **kwargs_):
        if alternativeNameType2.subclass:
            return alternativeNameType2.subclass(*args_, **kwargs_)
        else:
            return alternativeNameType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fullName(self): return self.fullName
    def set_fullName(self, fullName): self.fullName = fullName
    def get_shortName(self): return self.shortName
    def set_shortName(self, shortName): self.shortName = shortName
    def add_shortName(self, value): self.shortName.append(value)
    def insert_shortName_at(self, index, value): self.shortName.insert(index, value)
    def replace_shortName_at(self, index, value): self.shortName[index] = value
    def get_ecNumber(self): return self.ecNumber
    def set_ecNumber(self, ecNumber): self.ecNumber = ecNumber
    def add_ecNumber(self, value): self.ecNumber.append(value)
    def insert_ecNumber_at(self, index, value): self.ecNumber.insert(index, value)
    def replace_ecNumber_at(self, index, value): self.ecNumber[index] = value
    def hasContent_(self):
        if (
            self.fullName is not None or
            self.shortName or
            self.ecNumber
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='alternativeNameType2', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='alternativeNameType2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='alternativeNameType2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='alternativeNameType2'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='alternativeNameType2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fullName is not None:
            self.fullName.export(outfile, level, namespace_, name_='fullName', pretty_print=pretty_print)
        for shortName_ in self.shortName:
            shortName_.export(outfile, level, namespace_, name_='shortName', pretty_print=pretty_print)
        for ecNumber_ in self.ecNumber:
            ecNumber_.export(outfile, level, namespace_, name_='ecNumber', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fullName':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.fullName = obj_
            obj_.original_tagname_ = 'fullName'
        elif nodeName_ == 'shortName':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.shortName.append(obj_)
            obj_.original_tagname_ = 'shortName'
        elif nodeName_ == 'ecNumber':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.ecNumber.append(obj_)
            obj_.original_tagname_ = 'ecNumber'
# end class alternativeNameType2


class submittedNameType3(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, fullName=None, ecNumber=None):
        self.original_tagname_ = None
        self.fullName = fullName
        if ecNumber is None:
            self.ecNumber = []
        else:
            self.ecNumber = ecNumber
    def factory(*args_, **kwargs_):
        if submittedNameType3.subclass:
            return submittedNameType3.subclass(*args_, **kwargs_)
        else:
            return submittedNameType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fullName(self): return self.fullName
    def set_fullName(self, fullName): self.fullName = fullName
    def get_ecNumber(self): return self.ecNumber
    def set_ecNumber(self, ecNumber): self.ecNumber = ecNumber
    def add_ecNumber(self, value): self.ecNumber.append(value)
    def insert_ecNumber_at(self, index, value): self.ecNumber.insert(index, value)
    def replace_ecNumber_at(self, index, value): self.ecNumber[index] = value
    def hasContent_(self):
        if (
            self.fullName is not None or
            self.ecNumber
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='submittedNameType3', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='submittedNameType3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='submittedNameType3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='submittedNameType3'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='submittedNameType3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fullName is not None:
            self.fullName.export(outfile, level, namespace_, name_='fullName', pretty_print=pretty_print)
        for ecNumber_ in self.ecNumber:
            ecNumber_.export(outfile, level, namespace_, name_='ecNumber', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fullName':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.fullName = obj_
            obj_.original_tagname_ = 'fullName'
        elif nodeName_ == 'ecNumber':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.ecNumber.append(obj_)
            obj_.original_tagname_ = 'ecNumber'
# end class submittedNameType3


class componentType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, recommendedName=None, alternativeName=None, submittedName=None, allergenName=None, biotechName=None, cdAntigenName=None, innName=None):
        self.original_tagname_ = None
        self.recommendedName = recommendedName
        if alternativeName is None:
            self.alternativeName = []
        else:
            self.alternativeName = alternativeName
        if submittedName is None:
            self.submittedName = []
        else:
            self.submittedName = submittedName
        self.allergenName = allergenName
        self.biotechName = biotechName
        if cdAntigenName is None:
            self.cdAntigenName = []
        else:
            self.cdAntigenName = cdAntigenName
        if innName is None:
            self.innName = []
        else:
            self.innName = innName
    def factory(*args_, **kwargs_):
        if componentType.subclass:
            return componentType.subclass(*args_, **kwargs_)
        else:
            return componentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_recommendedName(self): return self.recommendedName
    def set_recommendedName(self, recommendedName): self.recommendedName = recommendedName
    def get_alternativeName(self): return self.alternativeName
    def set_alternativeName(self, alternativeName): self.alternativeName = alternativeName
    def add_alternativeName(self, value): self.alternativeName.append(value)
    def insert_alternativeName_at(self, index, value): self.alternativeName.insert(index, value)
    def replace_alternativeName_at(self, index, value): self.alternativeName[index] = value
    def get_submittedName(self): return self.submittedName
    def set_submittedName(self, submittedName): self.submittedName = submittedName
    def add_submittedName(self, value): self.submittedName.append(value)
    def insert_submittedName_at(self, index, value): self.submittedName.insert(index, value)
    def replace_submittedName_at(self, index, value): self.submittedName[index] = value
    def get_allergenName(self): return self.allergenName
    def set_allergenName(self, allergenName): self.allergenName = allergenName
    def get_biotechName(self): return self.biotechName
    def set_biotechName(self, biotechName): self.biotechName = biotechName
    def get_cdAntigenName(self): return self.cdAntigenName
    def set_cdAntigenName(self, cdAntigenName): self.cdAntigenName = cdAntigenName
    def add_cdAntigenName(self, value): self.cdAntigenName.append(value)
    def insert_cdAntigenName_at(self, index, value): self.cdAntigenName.insert(index, value)
    def replace_cdAntigenName_at(self, index, value): self.cdAntigenName[index] = value
    def get_innName(self): return self.innName
    def set_innName(self, innName): self.innName = innName
    def add_innName(self, value): self.innName.append(value)
    def insert_innName_at(self, index, value): self.innName.insert(index, value)
    def replace_innName_at(self, index, value): self.innName[index] = value
    def hasContent_(self):
        if (
            self.recommendedName is not None or
            self.alternativeName or
            self.submittedName or
            self.allergenName is not None or
            self.biotechName is not None or
            self.cdAntigenName or
            self.innName
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='componentType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='componentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='componentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='componentType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='componentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.recommendedName is not None:
            self.recommendedName.export(outfile, level, namespace_, name_='recommendedName', pretty_print=pretty_print)
        for alternativeName_ in self.alternativeName:
            alternativeName_.export(outfile, level, namespace_, name_='alternativeName', pretty_print=pretty_print)
        for submittedName_ in self.submittedName:
            submittedName_.export(outfile, level, namespace_, name_='submittedName', pretty_print=pretty_print)
        if self.allergenName is not None:
            self.allergenName.export(outfile, level, namespace_, name_='allergenName', pretty_print=pretty_print)
        if self.biotechName is not None:
            self.biotechName.export(outfile, level, namespace_, name_='biotechName', pretty_print=pretty_print)
        for cdAntigenName_ in self.cdAntigenName:
            cdAntigenName_.export(outfile, level, namespace_, name_='cdAntigenName', pretty_print=pretty_print)
        for innName_ in self.innName:
            innName_.export(outfile, level, namespace_, name_='innName', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'recommendedName':
            obj_ = recommendedNameType4.factory()
            obj_.build(child_)
            self.recommendedName = obj_
            obj_.original_tagname_ = 'recommendedName'
        elif nodeName_ == 'alternativeName':
            obj_ = alternativeNameType5.factory()
            obj_.build(child_)
            self.alternativeName.append(obj_)
            obj_.original_tagname_ = 'alternativeName'
        elif nodeName_ == 'submittedName':
            obj_ = submittedNameType6.factory()
            obj_.build(child_)
            self.submittedName.append(obj_)
            obj_.original_tagname_ = 'submittedName'
        elif nodeName_ == 'allergenName':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.allergenName = obj_
            obj_.original_tagname_ = 'allergenName'
        elif nodeName_ == 'biotechName':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.biotechName = obj_
            obj_.original_tagname_ = 'biotechName'
        elif nodeName_ == 'cdAntigenName':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.cdAntigenName.append(obj_)
            obj_.original_tagname_ = 'cdAntigenName'
        elif nodeName_ == 'innName':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.innName.append(obj_)
            obj_.original_tagname_ = 'innName'
# end class componentType


class recommendedNameType4(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, fullName=None, shortName=None, ecNumber=None):
        self.original_tagname_ = None
        self.fullName = fullName
        if shortName is None:
            self.shortName = []
        else:
            self.shortName = shortName
        if ecNumber is None:
            self.ecNumber = []
        else:
            self.ecNumber = ecNumber
    def factory(*args_, **kwargs_):
        if recommendedNameType4.subclass:
            return recommendedNameType4.subclass(*args_, **kwargs_)
        else:
            return recommendedNameType4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fullName(self): return self.fullName
    def set_fullName(self, fullName): self.fullName = fullName
    def get_shortName(self): return self.shortName
    def set_shortName(self, shortName): self.shortName = shortName
    def add_shortName(self, value): self.shortName.append(value)
    def insert_shortName_at(self, index, value): self.shortName.insert(index, value)
    def replace_shortName_at(self, index, value): self.shortName[index] = value
    def get_ecNumber(self): return self.ecNumber
    def set_ecNumber(self, ecNumber): self.ecNumber = ecNumber
    def add_ecNumber(self, value): self.ecNumber.append(value)
    def insert_ecNumber_at(self, index, value): self.ecNumber.insert(index, value)
    def replace_ecNumber_at(self, index, value): self.ecNumber[index] = value
    def hasContent_(self):
        if (
            self.fullName is not None or
            self.shortName or
            self.ecNumber
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='recommendedNameType4', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='recommendedNameType4')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='recommendedNameType4', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='recommendedNameType4'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='recommendedNameType4', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fullName is not None:
            self.fullName.export(outfile, level, namespace_, name_='fullName', pretty_print=pretty_print)
        for shortName_ in self.shortName:
            shortName_.export(outfile, level, namespace_, name_='shortName', pretty_print=pretty_print)
        for ecNumber_ in self.ecNumber:
            ecNumber_.export(outfile, level, namespace_, name_='ecNumber', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fullName':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.fullName = obj_
            obj_.original_tagname_ = 'fullName'
        elif nodeName_ == 'shortName':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.shortName.append(obj_)
            obj_.original_tagname_ = 'shortName'
        elif nodeName_ == 'ecNumber':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.ecNumber.append(obj_)
            obj_.original_tagname_ = 'ecNumber'
# end class recommendedNameType4


class alternativeNameType5(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, fullName=None, shortName=None, ecNumber=None):
        self.original_tagname_ = None
        self.fullName = fullName
        if shortName is None:
            self.shortName = []
        else:
            self.shortName = shortName
        if ecNumber is None:
            self.ecNumber = []
        else:
            self.ecNumber = ecNumber
    def factory(*args_, **kwargs_):
        if alternativeNameType5.subclass:
            return alternativeNameType5.subclass(*args_, **kwargs_)
        else:
            return alternativeNameType5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fullName(self): return self.fullName
    def set_fullName(self, fullName): self.fullName = fullName
    def get_shortName(self): return self.shortName
    def set_shortName(self, shortName): self.shortName = shortName
    def add_shortName(self, value): self.shortName.append(value)
    def insert_shortName_at(self, index, value): self.shortName.insert(index, value)
    def replace_shortName_at(self, index, value): self.shortName[index] = value
    def get_ecNumber(self): return self.ecNumber
    def set_ecNumber(self, ecNumber): self.ecNumber = ecNumber
    def add_ecNumber(self, value): self.ecNumber.append(value)
    def insert_ecNumber_at(self, index, value): self.ecNumber.insert(index, value)
    def replace_ecNumber_at(self, index, value): self.ecNumber[index] = value
    def hasContent_(self):
        if (
            self.fullName is not None or
            self.shortName or
            self.ecNumber
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='alternativeNameType5', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='alternativeNameType5')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='alternativeNameType5', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='alternativeNameType5'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='alternativeNameType5', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fullName is not None:
            self.fullName.export(outfile, level, namespace_, name_='fullName', pretty_print=pretty_print)
        for shortName_ in self.shortName:
            shortName_.export(outfile, level, namespace_, name_='shortName', pretty_print=pretty_print)
        for ecNumber_ in self.ecNumber:
            ecNumber_.export(outfile, level, namespace_, name_='ecNumber', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fullName':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.fullName = obj_
            obj_.original_tagname_ = 'fullName'
        elif nodeName_ == 'shortName':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.shortName.append(obj_)
            obj_.original_tagname_ = 'shortName'
        elif nodeName_ == 'ecNumber':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.ecNumber.append(obj_)
            obj_.original_tagname_ = 'ecNumber'
# end class alternativeNameType5


class submittedNameType6(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, fullName=None, ecNumber=None):
        self.original_tagname_ = None
        self.fullName = fullName
        if ecNumber is None:
            self.ecNumber = []
        else:
            self.ecNumber = ecNumber
    def factory(*args_, **kwargs_):
        if submittedNameType6.subclass:
            return submittedNameType6.subclass(*args_, **kwargs_)
        else:
            return submittedNameType6(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fullName(self): return self.fullName
    def set_fullName(self, fullName): self.fullName = fullName
    def get_ecNumber(self): return self.ecNumber
    def set_ecNumber(self, ecNumber): self.ecNumber = ecNumber
    def add_ecNumber(self, value): self.ecNumber.append(value)
    def insert_ecNumber_at(self, index, value): self.ecNumber.insert(index, value)
    def replace_ecNumber_at(self, index, value): self.ecNumber[index] = value
    def hasContent_(self):
        if (
            self.fullName is not None or
            self.ecNumber
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='submittedNameType6', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='submittedNameType6')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='submittedNameType6', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='submittedNameType6'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='submittedNameType6', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fullName is not None:
            self.fullName.export(outfile, level, namespace_, name_='fullName', pretty_print=pretty_print)
        for ecNumber_ in self.ecNumber:
            ecNumber_.export(outfile, level, namespace_, name_='ecNumber', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fullName':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.fullName = obj_
            obj_.original_tagname_ = 'fullName'
        elif nodeName_ == 'ecNumber':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.ecNumber.append(obj_)
            obj_.original_tagname_ = 'ecNumber'
# end class submittedNameType6


class recommendedNameType7(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, fullName=None, shortName=None, ecNumber=None):
        self.original_tagname_ = None
        self.fullName = fullName
        if shortName is None:
            self.shortName = []
        else:
            self.shortName = shortName
        if ecNumber is None:
            self.ecNumber = []
        else:
            self.ecNumber = ecNumber
    def factory(*args_, **kwargs_):
        if recommendedNameType7.subclass:
            return recommendedNameType7.subclass(*args_, **kwargs_)
        else:
            return recommendedNameType7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fullName(self): return self.fullName
    def set_fullName(self, fullName): self.fullName = fullName
    def get_shortName(self): return self.shortName
    def set_shortName(self, shortName): self.shortName = shortName
    def add_shortName(self, value): self.shortName.append(value)
    def insert_shortName_at(self, index, value): self.shortName.insert(index, value)
    def replace_shortName_at(self, index, value): self.shortName[index] = value
    def get_ecNumber(self): return self.ecNumber
    def set_ecNumber(self, ecNumber): self.ecNumber = ecNumber
    def add_ecNumber(self, value): self.ecNumber.append(value)
    def insert_ecNumber_at(self, index, value): self.ecNumber.insert(index, value)
    def replace_ecNumber_at(self, index, value): self.ecNumber[index] = value
    def hasContent_(self):
        if (
            self.fullName is not None or
            self.shortName or
            self.ecNumber
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='recommendedNameType7', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='recommendedNameType7')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='recommendedNameType7', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='recommendedNameType7'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='recommendedNameType7', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fullName is not None:
            self.fullName.export(outfile, level, namespace_, name_='fullName', pretty_print=pretty_print)
        for shortName_ in self.shortName:
            shortName_.export(outfile, level, namespace_, name_='shortName', pretty_print=pretty_print)
        for ecNumber_ in self.ecNumber:
            ecNumber_.export(outfile, level, namespace_, name_='ecNumber', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fullName':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.fullName = obj_
            obj_.original_tagname_ = 'fullName'
        elif nodeName_ == 'shortName':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.shortName.append(obj_)
            obj_.original_tagname_ = 'shortName'
        elif nodeName_ == 'ecNumber':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.ecNumber.append(obj_)
            obj_.original_tagname_ = 'ecNumber'
# end class recommendedNameType7


class alternativeNameType8(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, fullName=None, shortName=None, ecNumber=None):
        self.original_tagname_ = None
        self.fullName = fullName
        if shortName is None:
            self.shortName = []
        else:
            self.shortName = shortName
        if ecNumber is None:
            self.ecNumber = []
        else:
            self.ecNumber = ecNumber
    def factory(*args_, **kwargs_):
        if alternativeNameType8.subclass:
            return alternativeNameType8.subclass(*args_, **kwargs_)
        else:
            return alternativeNameType8(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fullName(self): return self.fullName
    def set_fullName(self, fullName): self.fullName = fullName
    def get_shortName(self): return self.shortName
    def set_shortName(self, shortName): self.shortName = shortName
    def add_shortName(self, value): self.shortName.append(value)
    def insert_shortName_at(self, index, value): self.shortName.insert(index, value)
    def replace_shortName_at(self, index, value): self.shortName[index] = value
    def get_ecNumber(self): return self.ecNumber
    def set_ecNumber(self, ecNumber): self.ecNumber = ecNumber
    def add_ecNumber(self, value): self.ecNumber.append(value)
    def insert_ecNumber_at(self, index, value): self.ecNumber.insert(index, value)
    def replace_ecNumber_at(self, index, value): self.ecNumber[index] = value
    def hasContent_(self):
        if (
            self.fullName is not None or
            self.shortName or
            self.ecNumber
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='alternativeNameType8', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='alternativeNameType8')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='alternativeNameType8', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='alternativeNameType8'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='alternativeNameType8', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fullName is not None:
            self.fullName.export(outfile, level, namespace_, name_='fullName', pretty_print=pretty_print)
        for shortName_ in self.shortName:
            shortName_.export(outfile, level, namespace_, name_='shortName', pretty_print=pretty_print)
        for ecNumber_ in self.ecNumber:
            ecNumber_.export(outfile, level, namespace_, name_='ecNumber', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fullName':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.fullName = obj_
            obj_.original_tagname_ = 'fullName'
        elif nodeName_ == 'shortName':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.shortName.append(obj_)
            obj_.original_tagname_ = 'shortName'
        elif nodeName_ == 'ecNumber':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.ecNumber.append(obj_)
            obj_.original_tagname_ = 'ecNumber'
# end class alternativeNameType8


class submittedNameType9(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, fullName=None, ecNumber=None):
        self.original_tagname_ = None
        self.fullName = fullName
        if ecNumber is None:
            self.ecNumber = []
        else:
            self.ecNumber = ecNumber
    def factory(*args_, **kwargs_):
        if submittedNameType9.subclass:
            return submittedNameType9.subclass(*args_, **kwargs_)
        else:
            return submittedNameType9(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fullName(self): return self.fullName
    def set_fullName(self, fullName): self.fullName = fullName
    def get_ecNumber(self): return self.ecNumber
    def set_ecNumber(self, ecNumber): self.ecNumber = ecNumber
    def add_ecNumber(self, value): self.ecNumber.append(value)
    def insert_ecNumber_at(self, index, value): self.ecNumber.insert(index, value)
    def replace_ecNumber_at(self, index, value): self.ecNumber[index] = value
    def hasContent_(self):
        if (
            self.fullName is not None or
            self.ecNumber
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='submittedNameType9', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='submittedNameType9')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='submittedNameType9', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='submittedNameType9'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='submittedNameType9', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fullName is not None:
            self.fullName.export(outfile, level, namespace_, name_='fullName', pretty_print=pretty_print)
        for ecNumber_ in self.ecNumber:
            ecNumber_.export(outfile, level, namespace_, name_='ecNumber', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fullName':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.fullName = obj_
            obj_.original_tagname_ = 'fullName'
        elif nodeName_ == 'ecNumber':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.ecNumber.append(obj_)
            obj_.original_tagname_ = 'ecNumber'
# end class submittedNameType9


class lineageType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, taxon=None):
        self.original_tagname_ = None
        if taxon is None:
            self.taxon = []
        else:
            self.taxon = taxon
    def factory(*args_, **kwargs_):
        if lineageType.subclass:
            return lineageType.subclass(*args_, **kwargs_)
        else:
            return lineageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_taxon(self): return self.taxon
    def set_taxon(self, taxon): self.taxon = taxon
    def add_taxon(self, value): self.taxon.append(value)
    def insert_taxon_at(self, index, value): self.taxon.insert(index, value)
    def replace_taxon_at(self, index, value): self.taxon[index] = value
    def hasContent_(self):
        if (
            self.taxon
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='lineageType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='lineageType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='lineageType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='lineageType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='lineageType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for taxon_ in self.taxon:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%staxon>%s</%staxon>%s' % (namespace_, self.gds_format_string(quote_xml(taxon_).encode(ExternalEncoding), input_name='taxon'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'taxon':
            taxon_ = child_.text
            taxon_ = self.gds_validate_string(taxon_, node, 'taxon')
            self.taxon.append(taxon_)
# end class lineageType


class strainType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, evidence=None, valueOf_=None):
        self.original_tagname_ = None
        self.evidence = _cast(None, evidence)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if strainType.subclass:
            return strainType.subclass(*args_, **kwargs_)
        else:
            return strainType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_evidence(self): return self.evidence
    def set_evidence(self, evidence): self.evidence = evidence
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_intListType(self, value):
        # Validate type intListType, a restriction on xs:int.
        pass
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='strainType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='strainType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='strainType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='strainType'):
        if self.evidence is not None and 'evidence' not in already_processed:
            already_processed.add('evidence')
            outfile.write(' evidence=%s' % (quote_attrib(self.evidence), ))
    def exportChildren(self, outfile, level, namespace_='', name_='strainType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('evidence', node)
        if value is not None and 'evidence' not in already_processed:
            already_processed.add('evidence')
            try:
                self.evidence = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_intListType(self.evidence)    # validate type intListType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class strainType


class plasmidType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, evidence=None, valueOf_=None):
        self.original_tagname_ = None
        self.evidence = _cast(None, evidence)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if plasmidType.subclass:
            return plasmidType.subclass(*args_, **kwargs_)
        else:
            return plasmidType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_evidence(self): return self.evidence
    def set_evidence(self, evidence): self.evidence = evidence
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_intListType(self, value):
        # Validate type intListType, a restriction on xs:int.
        pass
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='plasmidType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='plasmidType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='plasmidType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='plasmidType'):
        if self.evidence is not None and 'evidence' not in already_processed:
            already_processed.add('evidence')
            outfile.write(' evidence=%s' % (quote_attrib(self.evidence), ))
    def exportChildren(self, outfile, level, namespace_='', name_='plasmidType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('evidence', node)
        if value is not None and 'evidence' not in already_processed:
            already_processed.add('evidence')
            try:
                self.evidence = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_intListType(self.evidence)    # validate type intListType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class plasmidType


class transposonType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, evidence=None, valueOf_=None):
        self.original_tagname_ = None
        self.evidence = _cast(None, evidence)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if transposonType.subclass:
            return transposonType.subclass(*args_, **kwargs_)
        else:
            return transposonType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_evidence(self): return self.evidence
    def set_evidence(self, evidence): self.evidence = evidence
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_intListType(self, value):
        # Validate type intListType, a restriction on xs:int.
        pass
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='transposonType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='transposonType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='transposonType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='transposonType'):
        if self.evidence is not None and 'evidence' not in already_processed:
            already_processed.add('evidence')
            outfile.write(' evidence=%s' % (quote_attrib(self.evidence), ))
    def exportChildren(self, outfile, level, namespace_='', name_='transposonType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('evidence', node)
        if value is not None and 'evidence' not in already_processed:
            already_processed.add('evidence')
            try:
                self.evidence = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_intListType(self.evidence)    # validate type intListType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class transposonType


class tissueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, evidence=None, valueOf_=None):
        self.original_tagname_ = None
        self.evidence = _cast(None, evidence)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if tissueType.subclass:
            return tissueType.subclass(*args_, **kwargs_)
        else:
            return tissueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_evidence(self): return self.evidence
    def set_evidence(self, evidence): self.evidence = evidence
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_intListType(self, value):
        # Validate type intListType, a restriction on xs:int.
        pass
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='tissueType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tissueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='tissueType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='tissueType'):
        if self.evidence is not None and 'evidence' not in already_processed:
            already_processed.add('evidence')
            outfile.write(' evidence=%s' % (quote_attrib(self.evidence), ))
    def exportChildren(self, outfile, level, namespace_='', name_='tissueType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('evidence', node)
        if value is not None and 'evidence' not in already_processed:
            already_processed.add('evidence')
            try:
                self.evidence = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_intListType(self.evidence)    # validate type intListType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tissueType


class absorptionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, max=None, text=None):
        self.original_tagname_ = None
        self.max = max
        if text is None:
            self.text = []
        else:
            self.text = text
    def factory(*args_, **kwargs_):
        if absorptionType.subclass:
            return absorptionType.subclass(*args_, **kwargs_)
        else:
            return absorptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_max(self): return self.max
    def set_max(self, max): self.max = max
    def get_text(self): return self.text
    def set_text(self, text): self.text = text
    def add_text(self, value): self.text.append(value)
    def insert_text_at(self, index, value): self.text.insert(index, value)
    def replace_text_at(self, index, value): self.text[index] = value
    def hasContent_(self):
        if (
            self.max is not None or
            self.text
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='absorptionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='absorptionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='absorptionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='absorptionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='absorptionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.max is not None:
            self.max.export(outfile, level, namespace_, name_='max', pretty_print=pretty_print)
        for text_ in self.text:
            text_.export(outfile, level, namespace_, name_='text', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'max':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.max = obj_
            obj_.original_tagname_ = 'max'
        elif nodeName_ == 'text':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.text.append(obj_)
            obj_.original_tagname_ = 'text'
# end class absorptionType


class kineticsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, KM=None, Vmax=None, text=None):
        self.original_tagname_ = None
        if KM is None:
            self.KM = []
        else:
            self.KM = KM
        if Vmax is None:
            self.Vmax = []
        else:
            self.Vmax = Vmax
        if text is None:
            self.text = []
        else:
            self.text = text
    def factory(*args_, **kwargs_):
        if kineticsType.subclass:
            return kineticsType.subclass(*args_, **kwargs_)
        else:
            return kineticsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_KM(self): return self.KM
    def set_KM(self, KM): self.KM = KM
    def add_KM(self, value): self.KM.append(value)
    def insert_KM_at(self, index, value): self.KM.insert(index, value)
    def replace_KM_at(self, index, value): self.KM[index] = value
    def get_Vmax(self): return self.Vmax
    def set_Vmax(self, Vmax): self.Vmax = Vmax
    def add_Vmax(self, value): self.Vmax.append(value)
    def insert_Vmax_at(self, index, value): self.Vmax.insert(index, value)
    def replace_Vmax_at(self, index, value): self.Vmax[index] = value
    def get_text(self): return self.text
    def set_text(self, text): self.text = text
    def add_text(self, value): self.text.append(value)
    def insert_text_at(self, index, value): self.text.insert(index, value)
    def replace_text_at(self, index, value): self.text[index] = value
    def hasContent_(self):
        if (
            self.KM or
            self.Vmax or
            self.text
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='kineticsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='kineticsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='kineticsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='kineticsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='kineticsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for KM_ in self.KM:
            KM_.export(outfile, level, namespace_, name_='KM', pretty_print=pretty_print)
        for Vmax_ in self.Vmax:
            Vmax_.export(outfile, level, namespace_, name_='Vmax', pretty_print=pretty_print)
        for text_ in self.text:
            text_.export(outfile, level, namespace_, name_='text', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'KM':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.KM.append(obj_)
            obj_.original_tagname_ = 'KM'
        elif nodeName_ == 'Vmax':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.Vmax.append(obj_)
            obj_.original_tagname_ = 'Vmax'
        elif nodeName_ == 'text':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.text.append(obj_)
            obj_.original_tagname_ = 'text'
# end class kineticsType


class phDependenceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, text=None):
        self.original_tagname_ = None
        if text is None:
            self.text = []
        else:
            self.text = text
    def factory(*args_, **kwargs_):
        if phDependenceType.subclass:
            return phDependenceType.subclass(*args_, **kwargs_)
        else:
            return phDependenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_text(self): return self.text
    def set_text(self, text): self.text = text
    def add_text(self, value): self.text.append(value)
    def insert_text_at(self, index, value): self.text.insert(index, value)
    def replace_text_at(self, index, value): self.text[index] = value
    def hasContent_(self):
        if (
            self.text
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='phDependenceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='phDependenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='phDependenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='phDependenceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='phDependenceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for text_ in self.text:
            text_.export(outfile, level, namespace_, name_='text', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'text':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.text.append(obj_)
            obj_.original_tagname_ = 'text'
# end class phDependenceType


class redoxPotentialType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, text=None):
        self.original_tagname_ = None
        if text is None:
            self.text = []
        else:
            self.text = text
    def factory(*args_, **kwargs_):
        if redoxPotentialType.subclass:
            return redoxPotentialType.subclass(*args_, **kwargs_)
        else:
            return redoxPotentialType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_text(self): return self.text
    def set_text(self, text): self.text = text
    def add_text(self, value): self.text.append(value)
    def insert_text_at(self, index, value): self.text.insert(index, value)
    def replace_text_at(self, index, value): self.text[index] = value
    def hasContent_(self):
        if (
            self.text
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='redoxPotentialType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='redoxPotentialType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='redoxPotentialType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='redoxPotentialType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='redoxPotentialType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for text_ in self.text:
            text_.export(outfile, level, namespace_, name_='text', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'text':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.text.append(obj_)
            obj_.original_tagname_ = 'text'
# end class redoxPotentialType


class temperatureDependenceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, text=None):
        self.original_tagname_ = None
        if text is None:
            self.text = []
        else:
            self.text = text
    def factory(*args_, **kwargs_):
        if temperatureDependenceType.subclass:
            return temperatureDependenceType.subclass(*args_, **kwargs_)
        else:
            return temperatureDependenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_text(self): return self.text
    def set_text(self, text): self.text = text
    def add_text(self, value): self.text.append(value)
    def insert_text_at(self, index, value): self.text.insert(index, value)
    def replace_text_at(self, index, value): self.text[index] = value
    def hasContent_(self):
        if (
            self.text
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='temperatureDependenceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='temperatureDependenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='temperatureDependenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='temperatureDependenceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='temperatureDependenceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for text_ in self.text:
            text_.export(outfile, level, namespace_, name_='text', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'text':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.text.append(obj_)
            obj_.original_tagname_ = 'text'
# end class temperatureDependenceType


class conflictType(GeneratedsSuper):
    """Refers to the 'key' attribute of a 'reference' element."""
    subclass = None
    superclass = None
    def __init__(self, ref=None, type_=None, sequence=None):
        self.original_tagname_ = None
        self.ref = _cast(None, ref)
        self.type_ = _cast(None, type_)
        self.sequence = sequence
    def factory(*args_, **kwargs_):
        if conflictType.subclass:
            return conflictType.subclass(*args_, **kwargs_)
        else:
            return conflictType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sequence(self): return self.sequence
    def set_sequence(self, sequence): self.sequence = sequence
    def get_ref(self): return self.ref
    def set_ref(self, ref): self.ref = ref
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.sequence is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='conflictType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='conflictType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='conflictType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='conflictType'):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_format_string(quote_attrib(self.ref).encode(ExternalEncoding), input_name='ref'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='conflictType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.sequence is not None:
            self.sequence.export(outfile, level, namespace_, name_='sequence', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'sequence':
            obj_ = sequenceType10.factory()
            obj_.build(child_)
            self.sequence = obj_
            obj_.original_tagname_ = 'sequence'
# end class conflictType


class sequenceType10(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, version=None, resource=None, id=None):
        self.original_tagname_ = None
        self.version = _cast(int, version)
        self.resource = _cast(None, resource)
        self.id = _cast(None, id)
    def factory(*args_, **kwargs_):
        if sequenceType10.subclass:
            return sequenceType10.subclass(*args_, **kwargs_)
        else:
            return sequenceType10(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_resource(self): return self.resource
    def set_resource(self, resource): self.resource = resource
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='sequenceType10', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sequenceType10')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='sequenceType10', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='sequenceType10'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version="%s"' % self.gds_format_integer(self.version, input_name='version'))
        if self.resource is not None and 'resource' not in already_processed:
            already_processed.add('resource')
            outfile.write(' resource=%s' % (self.gds_format_string(quote_attrib(self.resource).encode(ExternalEncoding), input_name='resource'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='sequenceType10', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            try:
                self.version = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('resource', node)
        if value is not None and 'resource' not in already_processed:
            already_processed.add('resource')
            self.resource = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class sequenceType10


class linkType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uri=None):
        self.original_tagname_ = None
        self.uri = _cast(None, uri)
    def factory(*args_, **kwargs_):
        if linkType.subclass:
            return linkType.subclass(*args_, **kwargs_)
        else:
            return linkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uri(self): return self.uri
    def set_uri(self, uri): self.uri = uri
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='linkType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='linkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='linkType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='linkType'):
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            outfile.write(' uri=%s' % (self.gds_format_string(quote_attrib(self.uri).encode(ExternalEncoding), input_name='uri'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='linkType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uri', node)
        if value is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            self.uri = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class linkType


class diseaseType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, acronym=None, description=None, dbReference=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.name = name
        self.acronym = acronym
        self.description = description
        self.dbReference = dbReference
    def factory(*args_, **kwargs_):
        if diseaseType.subclass:
            return diseaseType.subclass(*args_, **kwargs_)
        else:
            return diseaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_acronym(self): return self.acronym
    def set_acronym(self, acronym): self.acronym = acronym
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_dbReference(self): return self.dbReference
    def set_dbReference(self, dbReference): self.dbReference = dbReference
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.name is not None or
            self.acronym is not None or
            self.description is not None or
            self.dbReference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='diseaseType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='diseaseType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='diseaseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='diseaseType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='diseaseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.acronym is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sacronym>%s</%sacronym>%s' % (namespace_, self.gds_format_string(quote_xml(self.acronym).encode(ExternalEncoding), input_name='acronym'), namespace_, eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_, eol_))
        if self.dbReference is not None:
            self.dbReference.export(outfile, level, namespace_, name_='dbReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'acronym':
            acronym_ = child_.text
            acronym_ = self.gds_validate_string(acronym_, node, 'acronym')
            self.acronym = acronym_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'dbReference':
            obj_ = dbReferenceType.factory()
            obj_.build(child_)
            self.dbReference = obj_
            obj_.original_tagname_ = 'dbReference'
# end class diseaseType


class absorptionType11(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, max=None, text=None):
        self.original_tagname_ = None
        self.max = max
        if text is None:
            self.text = []
        else:
            self.text = text
    def factory(*args_, **kwargs_):
        if absorptionType11.subclass:
            return absorptionType11.subclass(*args_, **kwargs_)
        else:
            return absorptionType11(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_max(self): return self.max
    def set_max(self, max): self.max = max
    def get_text(self): return self.text
    def set_text(self, text): self.text = text
    def add_text(self, value): self.text.append(value)
    def insert_text_at(self, index, value): self.text.insert(index, value)
    def replace_text_at(self, index, value): self.text[index] = value
    def hasContent_(self):
        if (
            self.max is not None or
            self.text
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='absorptionType11', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='absorptionType11')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='absorptionType11', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='absorptionType11'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='absorptionType11', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.max is not None:
            self.max.export(outfile, level, namespace_, name_='max', pretty_print=pretty_print)
        for text_ in self.text:
            text_.export(outfile, level, namespace_, name_='text', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'max':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.max = obj_
            obj_.original_tagname_ = 'max'
        elif nodeName_ == 'text':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.text.append(obj_)
            obj_.original_tagname_ = 'text'
# end class absorptionType11


class kineticsType12(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, KM=None, Vmax=None, text=None):
        self.original_tagname_ = None
        if KM is None:
            self.KM = []
        else:
            self.KM = KM
        if Vmax is None:
            self.Vmax = []
        else:
            self.Vmax = Vmax
        if text is None:
            self.text = []
        else:
            self.text = text
    def factory(*args_, **kwargs_):
        if kineticsType12.subclass:
            return kineticsType12.subclass(*args_, **kwargs_)
        else:
            return kineticsType12(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_KM(self): return self.KM
    def set_KM(self, KM): self.KM = KM
    def add_KM(self, value): self.KM.append(value)
    def insert_KM_at(self, index, value): self.KM.insert(index, value)
    def replace_KM_at(self, index, value): self.KM[index] = value
    def get_Vmax(self): return self.Vmax
    def set_Vmax(self, Vmax): self.Vmax = Vmax
    def add_Vmax(self, value): self.Vmax.append(value)
    def insert_Vmax_at(self, index, value): self.Vmax.insert(index, value)
    def replace_Vmax_at(self, index, value): self.Vmax[index] = value
    def get_text(self): return self.text
    def set_text(self, text): self.text = text
    def add_text(self, value): self.text.append(value)
    def insert_text_at(self, index, value): self.text.insert(index, value)
    def replace_text_at(self, index, value): self.text[index] = value
    def hasContent_(self):
        if (
            self.KM or
            self.Vmax or
            self.text
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='kineticsType12', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='kineticsType12')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='kineticsType12', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='kineticsType12'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='kineticsType12', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for KM_ in self.KM:
            KM_.export(outfile, level, namespace_, name_='KM', pretty_print=pretty_print)
        for Vmax_ in self.Vmax:
            Vmax_.export(outfile, level, namespace_, name_='Vmax', pretty_print=pretty_print)
        for text_ in self.text:
            text_.export(outfile, level, namespace_, name_='text', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'KM':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.KM.append(obj_)
            obj_.original_tagname_ = 'KM'
        elif nodeName_ == 'Vmax':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.Vmax.append(obj_)
            obj_.original_tagname_ = 'Vmax'
        elif nodeName_ == 'text':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.text.append(obj_)
            obj_.original_tagname_ = 'text'
# end class kineticsType12


class phDependenceType13(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, text=None):
        self.original_tagname_ = None
        if text is None:
            self.text = []
        else:
            self.text = text
    def factory(*args_, **kwargs_):
        if phDependenceType13.subclass:
            return phDependenceType13.subclass(*args_, **kwargs_)
        else:
            return phDependenceType13(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_text(self): return self.text
    def set_text(self, text): self.text = text
    def add_text(self, value): self.text.append(value)
    def insert_text_at(self, index, value): self.text.insert(index, value)
    def replace_text_at(self, index, value): self.text[index] = value
    def hasContent_(self):
        if (
            self.text
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='phDependenceType13', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='phDependenceType13')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='phDependenceType13', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='phDependenceType13'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='phDependenceType13', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for text_ in self.text:
            text_.export(outfile, level, namespace_, name_='text', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'text':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.text.append(obj_)
            obj_.original_tagname_ = 'text'
# end class phDependenceType13


class redoxPotentialType14(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, text=None):
        self.original_tagname_ = None
        if text is None:
            self.text = []
        else:
            self.text = text
    def factory(*args_, **kwargs_):
        if redoxPotentialType14.subclass:
            return redoxPotentialType14.subclass(*args_, **kwargs_)
        else:
            return redoxPotentialType14(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_text(self): return self.text
    def set_text(self, text): self.text = text
    def add_text(self, value): self.text.append(value)
    def insert_text_at(self, index, value): self.text.insert(index, value)
    def replace_text_at(self, index, value): self.text[index] = value
    def hasContent_(self):
        if (
            self.text
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='redoxPotentialType14', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='redoxPotentialType14')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='redoxPotentialType14', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='redoxPotentialType14'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='redoxPotentialType14', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for text_ in self.text:
            text_.export(outfile, level, namespace_, name_='text', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'text':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.text.append(obj_)
            obj_.original_tagname_ = 'text'
# end class redoxPotentialType14


class temperatureDependenceType15(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, text=None):
        self.original_tagname_ = None
        if text is None:
            self.text = []
        else:
            self.text = text
    def factory(*args_, **kwargs_):
        if temperatureDependenceType15.subclass:
            return temperatureDependenceType15.subclass(*args_, **kwargs_)
        else:
            return temperatureDependenceType15(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_text(self): return self.text
    def set_text(self, text): self.text = text
    def add_text(self, value): self.text.append(value)
    def insert_text_at(self, index, value): self.text.insert(index, value)
    def replace_text_at(self, index, value): self.text[index] = value
    def hasContent_(self):
        if (
            self.text
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='temperatureDependenceType15', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='temperatureDependenceType15')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='temperatureDependenceType15', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='temperatureDependenceType15'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='temperatureDependenceType15', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for text_ in self.text:
            text_.export(outfile, level, namespace_, name_='text', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'text':
            obj_ = evidencedStringType.factory()
            obj_.build(child_)
            self.text.append(obj_)
            obj_.original_tagname_ = 'text'
# end class temperatureDependenceType15


class nameType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, evidence=None, valueOf_=None):
        self.original_tagname_ = None
        self.evidence = _cast(None, evidence)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if nameType.subclass:
            return nameType.subclass(*args_, **kwargs_)
        else:
            return nameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_evidence(self): return self.evidence
    def set_evidence(self, evidence): self.evidence = evidence
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_intListType(self, value):
        # Validate type intListType, a restriction on xs:int.
        pass
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='nameType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nameType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='nameType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='nameType'):
        if self.evidence is not None and 'evidence' not in already_processed:
            already_processed.add('evidence')
            outfile.write(' evidence=%s' % (quote_attrib(self.evidence), ))
    def exportChildren(self, outfile, level, namespace_='', name_='nameType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('evidence', node)
        if value is not None and 'evidence' not in already_processed:
            already_processed.add('evidence')
            try:
                self.evidence = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_intListType(self.evidence)    # validate type intListType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nameType


class sequenceType16(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ref=None, type_=None):
        self.original_tagname_ = None
        self.ref = _cast(None, ref)
        self.type_ = _cast(None, type_)
    def factory(*args_, **kwargs_):
        if sequenceType16.subclass:
            return sequenceType16.subclass(*args_, **kwargs_)
        else:
            return sequenceType16(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ref(self): return self.ref
    def set_ref(self, ref): self.ref = ref
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='sequenceType16', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sequenceType16')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='sequenceType16', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='sequenceType16'):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            outfile.write(' ref=%s' % (self.gds_format_string(quote_attrib(self.ref).encode(ExternalEncoding), input_name='ref'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='sequenceType16', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.add('ref')
            self.ref = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class sequenceType16


GDSClassesMapping = {
    'comment': commentType,
    'domain': domainType,
    'orientation': evidencedStringType,
    'reference': referenceType,
    'sequence': sequenceType10,
    'text': evidencedStringType,
    'citation': citationType,
    'interactant': interactantType,
    'evidence': evidenceType,
    'strain': strainType,
    'tissue': tissueType,
    'protein': proteinType,
    'property': propertyType,
    'temperatureDependence': temperatureDependenceType,
    'event': eventType,
    'cofactor': cofactorType,
    'authorList': nameListType,
    'end': positionType,
    'organismHost': organismType,
    'alternativeName': alternativeNameType5,
    'consortium': consortiumType,
    'isoform': isoformType,
    'allergenName': evidencedStringType,
    'feature': featureType,
    'innName': evidencedStringType,
    'source': sourceType,
    'location': locationType,
    'max': evidencedStringType,
    'biotechName': evidencedStringType,
    'ecNumber': evidencedStringType,
    'conflict': conflictType,
    'submittedName': submittedNameType6,
    'begin': positionType,
    'redoxPotential': redoxPotentialType,
    'geneLocation': geneLocationType,
    'shortName': evidencedStringType,
    'transposon': transposonType,
    'Vmax': evidencedStringType,
    'component': componentType,
    'dbReference': dbReferenceType,
    'cdAntigenName': evidencedStringType,
    'subcellularLocation': subcellularLocationType,
    'phDependence': phDependenceType,
    'link': linkType,
    'fullName': evidencedStringType,
    'editorList': nameListType,
    'topology': evidencedStringType,
    'lineage': lineageType,
    'gene': geneType,
    'name': nameType,
    'keyword': keywordType,
    'kinetics': kineticsType,
    'disease': diseaseType,
    'KM': evidencedStringType,
    'person': personType,
    'molecule': moleculeType,
    'plasmid': plasmidType,
    'absorption': absorptionType,
    'importedFrom': importedFromType,
    'position': positionType,
    'recommendedName': recommendedNameType4,
    'organism': organismType,
    'proteinExistence': proteinExistenceType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'uniprot'
        rootClass = uniprot
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'uniprot'
        rootClass = uniprot
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    parser = None
    doc = parsexml_(StringIO(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'uniprot'
        rootClass = uniprot
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'uniprot'
        rootClass = uniprot
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from uniprot.xsd import *\n\n')
        sys.stdout.write('import uniprot.xsd as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "absorptionType",
    "absorptionType11",
    "alternativeNameType",
    "alternativeNameType2",
    "alternativeNameType5",
    "alternativeNameType8",
    "citationType",
    "cofactorType",
    "commentType",
    "componentType",
    "conflictType",
    "consortiumType",
    "dbReferenceType",
    "diseaseType",
    "domainType",
    "entry",
    "eventType",
    "evidenceType",
    "evidencedStringType",
    "featureType",
    "geneLocationType",
    "geneNameType",
    "geneType",
    "importedFromType",
    "interactantType",
    "isoformType",
    "keywordType",
    "kineticsType",
    "kineticsType12",
    "lineageType",
    "linkType",
    "locationType",
    "moleculeType",
    "nameListType",
    "nameType",
    "organismNameType",
    "organismType",
    "personType",
    "phDependenceType",
    "phDependenceType13",
    "plasmidType",
    "positionType",
    "propertyType",
    "proteinExistenceType",
    "proteinType",
    "recommendedNameType",
    "recommendedNameType1",
    "recommendedNameType4",
    "recommendedNameType7",
    "redoxPotentialType",
    "redoxPotentialType14",
    "referenceType",
    "sequenceType",
    "sequenceType10",
    "sequenceType16",
    "sourceDataType",
    "sourceType",
    "statusType",
    "strainType",
    "subcellularLocationType",
    "submittedNameType",
    "submittedNameType3",
    "submittedNameType6",
    "submittedNameType9",
    "temperatureDependenceType",
    "temperatureDependenceType15",
    "tissueType",
    "transposonType",
    "uniprot"
]
